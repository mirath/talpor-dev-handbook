{
    "docs": [
        {
            "location": "/", 
            "text": "The talPor Philosophy\n\n\nIntroduction\n\n\nWhether you are onboarding on a new project, or just hotfixing a\nproblem in an old one, software development is \nhard\n.\n\n\nBuilding software is not only technically hard, but like any other\nproblem, it depends highly on the human factor. Successfully shaping\nand taking ideas from just a thought all the way into a successful\nproduct involves tons of work. From the starting point, many\nvariables, like your client, developers, designers, among others, must\nbe aligned towards the goal of successfully shipping the product.\n\n\nThis document intends to outline what we believe to be the best\npractices at all the stages related to software development. As\nanything, it isn't written in stone, but rather is what we believe to\nbe sound advice in making software development successful.\n\n\nThe Guiding Principles\n\n\nAt \ntalPor\n, we function as a multi-disciplinary,\ndistributed team.  We tend to work on small teams (generally, by\nproject) which support and collaborate with each other. These guiding\nprinciples, enumerated below, are the core of our philosophy. Embrace\nthem, and put them to practice.\n\n\n\n\n\n\nDo not be afraid to make mistakes.\n Mistakes happen. You will\n   over or under-estimate that feature. You will completely\n   misunderstand your client. You will break a build for everyone in\n   your team. You will manage to take down production on a rainy\n   day. \nIt\n happens. And it will happen again. The whole point of\n   this philosophy is to \nminimize\n the number of times that happens.\n\n\n\n\n\n\nAlways try to do your best.\n Even if you have done it a million\n   times, or if it is the first time you get on board on a project,\n   always make solid decisions. It doesn't really matter if you have\n   been in the project from the get go, or you are just joining to\n   hotfix that annoying problem, take that extra time to first\n   \nunderstand\n the requirements, and then \nbuild\n or \nfix\n whatever\n   needs to be fixed as best as you possibly can.\n\n\n\n\n\n\nAsk for help.\n As previously said, we are a small team which is\n   always ready to provide help when needed. Don't be afraid to ask if\n   someone has ever done this or that. Don't be afraid to say you\n   don't know the answer. Don't be afraid to say you don't know how to\n   do something in particular. Likewise, offer your help or advice\n   when you do know what is going on.\n\n\n\n\n\n\nNever take it personally.\n This one is related to #1. It will\n   come the time when that feature branch you poured yourself into\n   will not make it to production. It will happen that your code will\n   take down production, or make the wrong assumptions. It will come\n   the time that you will be told you are doing it wrong. You are not\n   what you code or what you design, and you are not the project you\n   are on.\n\n\n\n\n\n\nBe impeccable with your words\n This one refers to the way you\n   express yourself. Words are much more than the constructs of\n   phrases that comes out of your mounth, they carry emotions,\n   actions, thoughts or attitudes.  Express yourself with integrity,\n   say what you mean and avoid your \nword\n to express jealousy, envy,\n   frustration, fear or anger. We respect each other ideas and\n   thoughts.\n\n\n\n\n\n\nDon't make assumptions\n When you are working on teams,\n   communication is fundamental to guarantee success in any\n   project. You cannot assume what others think, so being a little\n   verbose is not that bad. Misunderstandings occurs and you may end\n   up not deploying something into production because you assumed that\n   another one was going to do it.\n\n\n\n\n\n\nWho is this for?\n\n\nThis document is primarily geared towards any talPor employees. It is\nintended to contain glimpses of what we believe to be solid software\nengineering, from the project conception phase up to pivoting and\niterations of a project.\n\n\nAs such, anyone that partakes in any of the phases of software\ndevelopment, can benefit from reading and practicing what is on this\ndocument.\n\n\nHow is this document structured?\n\n\nThe rest of this document is structured trying to follow the common\nsoftware development flow.\n\n\n\n\n\n\nConception\n happens from the minute a new\n   client walks in, or a new internal project is started. Meeting the\n   client, understanding requirements, forming teams, estimating\n   features all happens at this stage.\n\n\n\n\n\n\nDevelopment\n is when the first version\n   of the product is built. Smart technology decisions, good\n   practices, and impeccable communication are key at this stage. This\n   section is also were we go into detail about the methodology we use\n   during projects as well as best practices for development.\n\n\n\n\n\n\nDeployment\n of the project into\n   production. Dealing with showstopper bugs, the 90/10 rule, handling\n   staging and production servers, dealing with bugs on production,\n   continuous integration.", 
            "title": "Home"
        }, 
        {
            "location": "/#the-talpor-philosophy", 
            "text": "Introduction  Whether you are onboarding on a new project, or just hotfixing a\nproblem in an old one, software development is  hard .  Building software is not only technically hard, but like any other\nproblem, it depends highly on the human factor. Successfully shaping\nand taking ideas from just a thought all the way into a successful\nproduct involves tons of work. From the starting point, many\nvariables, like your client, developers, designers, among others, must\nbe aligned towards the goal of successfully shipping the product.  This document intends to outline what we believe to be the best\npractices at all the stages related to software development. As\nanything, it isn't written in stone, but rather is what we believe to\nbe sound advice in making software development successful.  The Guiding Principles  At  talPor , we function as a multi-disciplinary,\ndistributed team.  We tend to work on small teams (generally, by\nproject) which support and collaborate with each other. These guiding\nprinciples, enumerated below, are the core of our philosophy. Embrace\nthem, and put them to practice.    Do not be afraid to make mistakes.  Mistakes happen. You will\n   over or under-estimate that feature. You will completely\n   misunderstand your client. You will break a build for everyone in\n   your team. You will manage to take down production on a rainy\n   day.  It  happens. And it will happen again. The whole point of\n   this philosophy is to  minimize  the number of times that happens.    Always try to do your best.  Even if you have done it a million\n   times, or if it is the first time you get on board on a project,\n   always make solid decisions. It doesn't really matter if you have\n   been in the project from the get go, or you are just joining to\n   hotfix that annoying problem, take that extra time to first\n    understand  the requirements, and then  build  or  fix  whatever\n   needs to be fixed as best as you possibly can.    Ask for help.  As previously said, we are a small team which is\n   always ready to provide help when needed. Don't be afraid to ask if\n   someone has ever done this or that. Don't be afraid to say you\n   don't know the answer. Don't be afraid to say you don't know how to\n   do something in particular. Likewise, offer your help or advice\n   when you do know what is going on.    Never take it personally.  This one is related to #1. It will\n   come the time when that feature branch you poured yourself into\n   will not make it to production. It will happen that your code will\n   take down production, or make the wrong assumptions. It will come\n   the time that you will be told you are doing it wrong. You are not\n   what you code or what you design, and you are not the project you\n   are on.    Be impeccable with your words  This one refers to the way you\n   express yourself. Words are much more than the constructs of\n   phrases that comes out of your mounth, they carry emotions,\n   actions, thoughts or attitudes.  Express yourself with integrity,\n   say what you mean and avoid your  word  to express jealousy, envy,\n   frustration, fear or anger. We respect each other ideas and\n   thoughts.    Don't make assumptions  When you are working on teams,\n   communication is fundamental to guarantee success in any\n   project. You cannot assume what others think, so being a little\n   verbose is not that bad. Misunderstandings occurs and you may end\n   up not deploying something into production because you assumed that\n   another one was going to do it.    Who is this for?  This document is primarily geared towards any talPor employees. It is\nintended to contain glimpses of what we believe to be solid software\nengineering, from the project conception phase up to pivoting and\niterations of a project.  As such, anyone that partakes in any of the phases of software\ndevelopment, can benefit from reading and practicing what is on this\ndocument.  How is this document structured?  The rest of this document is structured trying to follow the common\nsoftware development flow.    Conception  happens from the minute a new\n   client walks in, or a new internal project is started. Meeting the\n   client, understanding requirements, forming teams, estimating\n   features all happens at this stage.    Development  is when the first version\n   of the product is built. Smart technology decisions, good\n   practices, and impeccable communication are key at this stage. This\n   section is also were we go into detail about the methodology we use\n   during projects as well as best practices for development.    Deployment  of the project into\n   production. Dealing with showstopper bugs, the 90/10 rule, handling\n   staging and production servers, dealing with bugs on production,\n   continuous integration.", 
            "title": "The talPor Philosophy"
        }, 
        {
            "location": "/conception/", 
            "text": "The Conception Phase\n\n\nThe conception phase begins at the moment a new project walks through\nthe door. The main focus at this stage is understanding the\nrequirements of the project, and the results of this whole process is\na set of mockups and estimations that fulfill those requirements.\n\n\nDuring this stage, the team that will be involved in a project is\nbuilt, taking into consideration what is known initially. The idea is\nthat each team member strengths can be used to successfully take the\nproject from zero to production in reasonable time.\n\n\nAt talPor, this process is known as \ndiscovery\n. During\ndiscovery, fast paced meetings between the client and the team take\nplace with the goal of defining the requirements and defining what\nwill be part of the \nMVP (Minimum Viable Product)\n. These meetings\nshould be happening as fast as schedule permits.\n\n\nGenerally, clients will want to build every conceivable feature that\nis remotely related to their idea. As such, generally there is a lot\nof noise when you try to figure out what is the real problem the\nclient is trying to solve. At this stage you want to understand and\nisolate what is the big problem at hand, and provide the tools to\nsolve it.\n\n\nAlso remember, at the end of the day, we are also developing the\nclient's idea. We are interested in the client to be successful, so we\nwant to be able, at the end of the development process and into the\nproduction stage, to (in)validate the path that has been chosen.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nListen to what the client says and want. \nTake notes\n.\n\n\n\n\n\n\nBe polite with your client but very assertive.\n\n\n\n\n\n\nExplain when something is not possible (or extremely hard).\n\n\n\n\n\n\nInvolve everybody, including the client, in the process. Don't take\n  ideas for granted, don't make assumptions, speak up when necessary.\n\n\n\n\n\n\nThe Feedback Loop\n\n\nThe feedback loop is the shape the discovery process takes as meetings\nwith the client take place. When the first meeting with the client\nhappens, it is expected that the client will talk and explain the\nproject to the team, while the team takes notes and asks questions. In\nthis meeting, most of the talk will be done by the client.\n\n\nAfter the first meeting, the team will start shaping up the\nrequirements the client talked about. Possibly, the team will come up\nwith wireframes or mockups, or some other way to visualize it. As the\nnext meeting with the client comes around (which should be as soon as\npossible), roles in the meeting slightly shift.\n\n\nDuring the second meeting, the team will present their mockups to the\nclient. It is expected that the client will have comments, questions\nor simply have more to add to what was already said. Again, the team\ntakes notes and gets the opportunity to ask more questions which help\nsolidify the vision of a project.\n\n\nThe internal work is repeated again, coming up with new visualizations\nof the requirements. As the next meeting comes around, the roles in\nthe meeting shift even more, with the team explaining the vision of\nthe requirements they have, and the client, ideally, aligning even\nfurther with that vision. More comments and questions can be posed by\nthe client, but ideally as every meeting with further developments\nhappen, the client will have less and less to say.\n\n\nThis loop continues, until a united vision between the team and the\nclient is agreed upon.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nPrepare before your client meeting and summarize what happens\n  after it.\n Take the time to do a short \npre-meeting\n with your\n  teammates to have a common understanding and goals in the meeting,\n  and a short \npost-meeting\n once the meeting is over.\n\n\n\n\n\n\nTry to validate your team hypothesis.\n For example, try to\n  propose ideas that are known to work instead of reinventing the\n  wheel.\n\n\n\n\n\n\nUse what is available to you.\n If this is not a new project, ask\n  to see Google Analytics data, or any data that the project has\n  available. Make better hypothesis using this.\n\n\n\n\n\n\nAssume as little as possible.\n If you can't validate, it's just a\n  hunch.\n\n\n\n\n\n\nSometimes, the client doesn't want to let go of a feature they deem\n  really important. Try to compromise, try to explain why it is not\n  possible. Explain that if that feature makes it into the final\n  vision for the MVP, other features will have to be dropped for now.\n\n\n\n\n\n\nThe whole point of the discovery is to converge on a concrete but\n  not final vision for the project. Sometimes, your client will always\n  have something more to say, if possible listen, if not, remind them\n  that this is a MVP and more time to build other features will always\n  be there afterwards.\n\n\n\n\n\n\nRemind your client there is space for more development after the MVP\n  is done. The point of bounding the reach of the MVP is to be able to\n  \nvalidate as soon as possible\n rather than when multiple months of\n  development have been poured into the wrong hypothesis.\n\n\n\n\n\n\nMockups\n\n\nMockups are one of the deliverables of the discovery process. It\nshould represent a very basic view of the direction the team is taking\nwith the project. During the discovery process, mockups should be used\nto aid the delivery of the vision by the team.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nWhile simple, mockups should be sufficient to represent the vision\n  the project will take. Don't overlook details, but be pragmatic\n  about them.\n\n\n\n\n\n\nCurrently, we use \nBalsamiq Mockups\n to build\n  mockups.\n\n\n\n\n\n\nEstimations\n\n\nEstimations are one of the deliverables of the discovery process. At\ntalPor, we use a system of \nuser stories and story points\n to\nestimate the features to be done in a project. A user story is a\nsentence of the form \"As a [actor], I want to [action]\". For example,\none possible user story is \"As a user, I want to log in\".\n\n\nEvery single feature that is proposed during the discovery process\nshould be turned into one or several user stories. Consider using\n\nthemes\n to classify user stories. For example, the previous user\nstory could be part of the \naccounts\n theme. \nEvery user story should\nbe estimated using story points.\n\n\nAt talPor we use a Fibonacci schemed story point system. We can assign\nto every task the following story points: 0, 0.5, 1, 2 (a day worth of\nwork), 3, 5, 8, 13, 20+ and ?. Our estimate is that every engineer can\nperform 10 story points a week, as such, assigning 8 to a task is\nsaying it is expected to take less than a week, and 13 more than one\nweek.\n\n\nAssigning story points to a task should be done by the engineering\nteam physically at the same place (or via a video conference if not\npossible). Ideally, each team member should have an app, a set of\ncards or pieces of paper with the possible story point values (0, 0.5,\n1, 2, 3, ...)  written on them.\n\n\nYou should start by agreeing upon a user story that you all estimate\nto be a 2, and another user story that you all estimate to be a 5.\nThe need for this is to set a baseline for comparison when estimating\nthe remaining cards. Once these have been agreed upon, for each user\nstory every team member shows the card with the story points they\nbelieve the story will take. If every member estimated the same, then\nthe value is recorded as the user story estimation. In case there was\na disagreement, a \nconsensus needs to be reached\n before an\nestimation can be recorded for the user story.\n\n\nOnce every user story is estimated, some calculations should be done\nto figure out the expected standard deviation for the user\nstories. There are internal spreadsheets available to do this. Using\nthose calculations, an expected delivery time for all the user stories\ncan be estimated. You can find a spreadsheet with the formats and\nformulas used for \nuser stories\n estimations\n\nhere\n.\n\n\nProjects generally have a time frame. If the expected delivery time\nexceeds the project time frame, then further negotiation is needed\nbetween the team and client, even if a common vision was agreed upon\nby both parties. Common ways to do this include removing user stories\nor changing their scopes or reach.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nYour estimation will probably be wrong.\n Humans are exceptionally\n  bad at estimating time, especially under-estimating it. Do your best to\n  keep the estimation as honest and real as possible.\n\n\n\n\n\n\nAccount for testing, deployment, bugfixing and other changes.\n\n  You will not always be building new features in the project. Account\n  for time building tests for the codebase, time spent making sure\n  deployment works, bugfixing or design changes.\n\n\n\n\n\n\nIf you find yourself using big story points for a user story, or\n  needing higher story points, consider splitting your user stories\n  into smaller more manageable user stories.\n\n\n\n\n\n\nKeep your estimations up-to-date in the project's\n  \nTrello\n board.", 
            "title": "Conception"
        }, 
        {
            "location": "/conception/#the-conception-phase", 
            "text": "The conception phase begins at the moment a new project walks through\nthe door. The main focus at this stage is understanding the\nrequirements of the project, and the results of this whole process is\na set of mockups and estimations that fulfill those requirements.  During this stage, the team that will be involved in a project is\nbuilt, taking into consideration what is known initially. The idea is\nthat each team member strengths can be used to successfully take the\nproject from zero to production in reasonable time.  At talPor, this process is known as  discovery . During\ndiscovery, fast paced meetings between the client and the team take\nplace with the goal of defining the requirements and defining what\nwill be part of the  MVP (Minimum Viable Product) . These meetings\nshould be happening as fast as schedule permits.  Generally, clients will want to build every conceivable feature that\nis remotely related to their idea. As such, generally there is a lot\nof noise when you try to figure out what is the real problem the\nclient is trying to solve. At this stage you want to understand and\nisolate what is the big problem at hand, and provide the tools to\nsolve it.  Also remember, at the end of the day, we are also developing the\nclient's idea. We are interested in the client to be successful, so we\nwant to be able, at the end of the development process and into the\nproduction stage, to (in)validate the path that has been chosen.  Always keep in mind:    Listen to what the client says and want.  Take notes .    Be polite with your client but very assertive.    Explain when something is not possible (or extremely hard).    Involve everybody, including the client, in the process. Don't take\n  ideas for granted, don't make assumptions, speak up when necessary.    The Feedback Loop  The feedback loop is the shape the discovery process takes as meetings\nwith the client take place. When the first meeting with the client\nhappens, it is expected that the client will talk and explain the\nproject to the team, while the team takes notes and asks questions. In\nthis meeting, most of the talk will be done by the client.  After the first meeting, the team will start shaping up the\nrequirements the client talked about. Possibly, the team will come up\nwith wireframes or mockups, or some other way to visualize it. As the\nnext meeting with the client comes around (which should be as soon as\npossible), roles in the meeting slightly shift.  During the second meeting, the team will present their mockups to the\nclient. It is expected that the client will have comments, questions\nor simply have more to add to what was already said. Again, the team\ntakes notes and gets the opportunity to ask more questions which help\nsolidify the vision of a project.  The internal work is repeated again, coming up with new visualizations\nof the requirements. As the next meeting comes around, the roles in\nthe meeting shift even more, with the team explaining the vision of\nthe requirements they have, and the client, ideally, aligning even\nfurther with that vision. More comments and questions can be posed by\nthe client, but ideally as every meeting with further developments\nhappen, the client will have less and less to say.  This loop continues, until a united vision between the team and the\nclient is agreed upon.  Always keep in mind:    Prepare before your client meeting and summarize what happens\n  after it.  Take the time to do a short  pre-meeting  with your\n  teammates to have a common understanding and goals in the meeting,\n  and a short  post-meeting  once the meeting is over.    Try to validate your team hypothesis.  For example, try to\n  propose ideas that are known to work instead of reinventing the\n  wheel.    Use what is available to you.  If this is not a new project, ask\n  to see Google Analytics data, or any data that the project has\n  available. Make better hypothesis using this.    Assume as little as possible.  If you can't validate, it's just a\n  hunch.    Sometimes, the client doesn't want to let go of a feature they deem\n  really important. Try to compromise, try to explain why it is not\n  possible. Explain that if that feature makes it into the final\n  vision for the MVP, other features will have to be dropped for now.    The whole point of the discovery is to converge on a concrete but\n  not final vision for the project. Sometimes, your client will always\n  have something more to say, if possible listen, if not, remind them\n  that this is a MVP and more time to build other features will always\n  be there afterwards.    Remind your client there is space for more development after the MVP\n  is done. The point of bounding the reach of the MVP is to be able to\n   validate as soon as possible  rather than when multiple months of\n  development have been poured into the wrong hypothesis.    Mockups  Mockups are one of the deliverables of the discovery process. It\nshould represent a very basic view of the direction the team is taking\nwith the project. During the discovery process, mockups should be used\nto aid the delivery of the vision by the team.  Always keep in mind:    While simple, mockups should be sufficient to represent the vision\n  the project will take. Don't overlook details, but be pragmatic\n  about them.    Currently, we use  Balsamiq Mockups  to build\n  mockups.    Estimations  Estimations are one of the deliverables of the discovery process. At\ntalPor, we use a system of  user stories and story points  to\nestimate the features to be done in a project. A user story is a\nsentence of the form \"As a [actor], I want to [action]\". For example,\none possible user story is \"As a user, I want to log in\".  Every single feature that is proposed during the discovery process\nshould be turned into one or several user stories. Consider using themes  to classify user stories. For example, the previous user\nstory could be part of the  accounts  theme.  Every user story should\nbe estimated using story points.  At talPor we use a Fibonacci schemed story point system. We can assign\nto every task the following story points: 0, 0.5, 1, 2 (a day worth of\nwork), 3, 5, 8, 13, 20+ and ?. Our estimate is that every engineer can\nperform 10 story points a week, as such, assigning 8 to a task is\nsaying it is expected to take less than a week, and 13 more than one\nweek.  Assigning story points to a task should be done by the engineering\nteam physically at the same place (or via a video conference if not\npossible). Ideally, each team member should have an app, a set of\ncards or pieces of paper with the possible story point values (0, 0.5,\n1, 2, 3, ...)  written on them.  You should start by agreeing upon a user story that you all estimate\nto be a 2, and another user story that you all estimate to be a 5.\nThe need for this is to set a baseline for comparison when estimating\nthe remaining cards. Once these have been agreed upon, for each user\nstory every team member shows the card with the story points they\nbelieve the story will take. If every member estimated the same, then\nthe value is recorded as the user story estimation. In case there was\na disagreement, a  consensus needs to be reached  before an\nestimation can be recorded for the user story.  Once every user story is estimated, some calculations should be done\nto figure out the expected standard deviation for the user\nstories. There are internal spreadsheets available to do this. Using\nthose calculations, an expected delivery time for all the user stories\ncan be estimated. You can find a spreadsheet with the formats and\nformulas used for  user stories  estimations here .  Projects generally have a time frame. If the expected delivery time\nexceeds the project time frame, then further negotiation is needed\nbetween the team and client, even if a common vision was agreed upon\nby both parties. Common ways to do this include removing user stories\nor changing their scopes or reach.  Always keep in mind:    Your estimation will probably be wrong.  Humans are exceptionally\n  bad at estimating time, especially under-estimating it. Do your best to\n  keep the estimation as honest and real as possible.    Account for testing, deployment, bugfixing and other changes. \n  You will not always be building new features in the project. Account\n  for time building tests for the codebase, time spent making sure\n  deployment works, bugfixing or design changes.    If you find yourself using big story points for a user story, or\n  needing higher story points, consider splitting your user stories\n  into smaller more manageable user stories.    Keep your estimations up-to-date in the project's\n   Trello  board.", 
            "title": "The Conception Phase"
        }, 
        {
            "location": "/development/", 
            "text": "The Development Phase\n\n\nThe development phase begins immediately after conception, together\nwith design it makes up the core of the software development\nprocess. For software engineers, the development phase is their time\nto shine. In this stage, user stories are scheduled for development on\na week-by-week basis for the engineering team to work on. Initially,\nthe focus is on building the functionality of the MVP, while the\ndesign team works in parallel designing the whole user interface and\nuser experience according to the user stories and mockups. Once the\ndesign team starts producing designs, those are to be implemented into\nthe final product that will be delivered.\n\n\nOnboarding\n\n\nRight before starting the development process, take the time to\nestablish clear and redundant communication paths between the client\nand the team. \nIt is preferable to over-communicate than to\nunder-communicate.\n\n\nGood communication is the #1 way to avoid overly long meetings and\nlast minute changes of heart. Involve the client, engage and\nlisten. Good communication between the team members avoids bugs and\nproblems down the road. As with the discovery meetings, take time to\nschedule \npre-\n and \npost-meetings\n where you review what was done and\nwhat will be done now.\n\n\nWhat you should do to onboard the project:\n\n\n\n\nSet up \nSlack\n for real time communication\n  with the client.  This involves going to\n  \nSlack\n and creating an account with the name\n  of the product or company\n  (i.e. \nhttp://talpor.slack.com\n).\n\n\nSet up a board on \nTrello\n in the talPor\n  organization to track what is being done on the project. Create the\n  recommended lists from our \nTrello section\n\n  of the methodology docs.\n\n\nUse the integrations between your tools, for example Slack-Trello\n  integration can be useful to notify the client new changes are\n  deployed.\n\n\nSchedule a fixed day and time for the weekly meeting with your\n  client.  \nBe on time\n. If you are being dilligent about keeping\n  your communication paths open, meetings should be just a summary of\n  what was done and what is going to be worked on during the week.\n\n\nSchedule meetings with your teammates before and after the weekly\n  meeting.  Details on what to do at each of these meetings can be\n  found in the \nMeeting section\n of the\n  Methodology docs.\n\n\n\n\nMethodology\n\n\nFor our development process we use an agile methodology. Our\nmethodology draws from Scrum and Extreme Programming (XP), both\nwell-known and well-documented agile methodologies. Therefore, to get\ndetails regarding our practices that escape the scope of this\nhandbook, the documentation for these methodologies is the place to\nlook.\n\n\nSo, what does using an agile methodology entail? It means we expect\nproject requirements to be constantly evolving and what we developed a\nweek ago can be very far from what we're building for tomorrow. You\nmight be wondering: \n\"What the hell? How are you supposed to plan and\nbuild software under those conditions?\"\n. Well, we do.\n\n\nAgile methodologies were born out of the inability of other\nmethodologies, like RUP or Waterfall, to adapt to unavoidable changes\nthat occur while a product is being developed. So how do we handle\nthis and keep our clients happy? We follow incremental design\nguidelines and an iterative development process in order to minimize\nthe risks that this constant evolution entails.\n\n\nThere are several techniques and weekly tasks that need to be followed\nas part of talPor's methodology so read on to the\n\nMethodology\n section for further detail of\nwhat needs to be done during a project's life cycle.\n\n\nTechnical standards\n\n\nWe're a tech company that builds products and in order to deliver a\ngreat product we need to be writing great code and using the best\ntools and software for the job. Also, in order to share our experience\nas a team, we need to be on the same page as to what software we're\nusing as well as how we're using it. To accomplish both those things\nwe have a set of standards and recommendations that are documented in\nthe \nTechnical Standards\n section.", 
            "title": "Introduction"
        }, 
        {
            "location": "/development/#the-development-phase", 
            "text": "The development phase begins immediately after conception, together\nwith design it makes up the core of the software development\nprocess. For software engineers, the development phase is their time\nto shine. In this stage, user stories are scheduled for development on\na week-by-week basis for the engineering team to work on. Initially,\nthe focus is on building the functionality of the MVP, while the\ndesign team works in parallel designing the whole user interface and\nuser experience according to the user stories and mockups. Once the\ndesign team starts producing designs, those are to be implemented into\nthe final product that will be delivered.  Onboarding  Right before starting the development process, take the time to\nestablish clear and redundant communication paths between the client\nand the team.  It is preferable to over-communicate than to\nunder-communicate.  Good communication is the #1 way to avoid overly long meetings and\nlast minute changes of heart. Involve the client, engage and\nlisten. Good communication between the team members avoids bugs and\nproblems down the road. As with the discovery meetings, take time to\nschedule  pre-  and  post-meetings  where you review what was done and\nwhat will be done now.  What you should do to onboard the project:   Set up  Slack  for real time communication\n  with the client.  This involves going to\n   Slack  and creating an account with the name\n  of the product or company\n  (i.e.  http://talpor.slack.com ).  Set up a board on  Trello  in the talPor\n  organization to track what is being done on the project. Create the\n  recommended lists from our  Trello section \n  of the methodology docs.  Use the integrations between your tools, for example Slack-Trello\n  integration can be useful to notify the client new changes are\n  deployed.  Schedule a fixed day and time for the weekly meeting with your\n  client.   Be on time . If you are being dilligent about keeping\n  your communication paths open, meetings should be just a summary of\n  what was done and what is going to be worked on during the week.  Schedule meetings with your teammates before and after the weekly\n  meeting.  Details on what to do at each of these meetings can be\n  found in the  Meeting section  of the\n  Methodology docs.   Methodology  For our development process we use an agile methodology. Our\nmethodology draws from Scrum and Extreme Programming (XP), both\nwell-known and well-documented agile methodologies. Therefore, to get\ndetails regarding our practices that escape the scope of this\nhandbook, the documentation for these methodologies is the place to\nlook.  So, what does using an agile methodology entail? It means we expect\nproject requirements to be constantly evolving and what we developed a\nweek ago can be very far from what we're building for tomorrow. You\nmight be wondering:  \"What the hell? How are you supposed to plan and\nbuild software under those conditions?\" . Well, we do.  Agile methodologies were born out of the inability of other\nmethodologies, like RUP or Waterfall, to adapt to unavoidable changes\nthat occur while a product is being developed. So how do we handle\nthis and keep our clients happy? We follow incremental design\nguidelines and an iterative development process in order to minimize\nthe risks that this constant evolution entails.  There are several techniques and weekly tasks that need to be followed\nas part of talPor's methodology so read on to the Methodology  section for further detail of\nwhat needs to be done during a project's life cycle.  Technical standards  We're a tech company that builds products and in order to deliver a\ngreat product we need to be writing great code and using the best\ntools and software for the job. Also, in order to share our experience\nas a team, we need to be on the same page as to what software we're\nusing as well as how we're using it. To accomplish both those things\nwe have a set of standards and recommendations that are documented in\nthe  Technical Standards  section.", 
            "title": "The Development Phase"
        }, 
        {
            "location": "/development/methodology/", 
            "text": "Introduction\n\n\nWhen you are working in a software development team, you need a set of\nwell-defined processes to empower organization, communication and\nefficient work. Moreover, inside a company, a standarized set of\nprocesses across every team will allow every project to be treated the\nsame way, delivering the same quality and facilitating coordination\namong teams.\n\n\nDevelopers tend to be (re-)assigned to different projects from time to\ntime. The presence of these well-defined processes will make this\nmigration smooth as the organizational knowledge of a project should\ncarry over from project to project (i.e. should be the same for any\nother project). This set of processes is what we call the\n\nmethodology\n.\n\n\nThis section is intented to give a detailed description of our\nmethodology, which entails every aspect of the way we work in\ntalPor. We will describe how we carry out our internals and clients\nmeetings, how is our setup for our agile development process,\nincluding the tools and processes we use to guarantee the correct\nappliance of our methodology, as well as the tools we use to gather\ninternal feedback about the projects statuses.", 
            "title": "Introduction"
        }, 
        {
            "location": "/development/methodology/#introduction", 
            "text": "When you are working in a software development team, you need a set of\nwell-defined processes to empower organization, communication and\nefficient work. Moreover, inside a company, a standarized set of\nprocesses across every team will allow every project to be treated the\nsame way, delivering the same quality and facilitating coordination\namong teams.  Developers tend to be (re-)assigned to different projects from time to\ntime. The presence of these well-defined processes will make this\nmigration smooth as the organizational knowledge of a project should\ncarry over from project to project (i.e. should be the same for any\nother project). This set of processes is what we call the methodology .  This section is intented to give a detailed description of our\nmethodology, which entails every aspect of the way we work in\ntalPor. We will describe how we carry out our internals and clients\nmeetings, how is our setup for our agile development process,\nincluding the tools and processes we use to guarantee the correct\nappliance of our methodology, as well as the tools we use to gather\ninternal feedback about the projects statuses.", 
            "title": "Introduction"
        }, 
        {
            "location": "/development/methodology/meetings/", 
            "text": "Meetings\n\n\nMeetings are very important in the development process as they ensure\nthat everybody is on the same page and is one of the primary ways to\ngive and receive feedback to and from our clients. But, at the same\ntime, meetings can become a painful process where the team feels that\nit's losing valuable time.\n\n\nMeeting tips\n\n\nBefore digging in to the particular process that we use at talPor, it\nwould be useful to keep some tips in mind to transform meetings into a\nproductive tool and a competitive advantage:\n\n\n\n\n\n\nStart on time and finish on time\n. People appreciate it when you\n  understand that their time is valuable. Another note on time: Do not\n  schedule any meetings to last longer than an hour. Sixty minutes is\n  generally the longest time workers can remain truly engaged.\n\n\n\n\n\n\nStick to your schedule\n. Create an agenda that lays out\n  everything you plan to cover in the meeting. Once you're in the\n  meeting, put that agenda somewhere accessible for everyone (Trello\n  is a great alternative) and guide the flow of the meeting according\n  to the points that are reflected there. This keeps people focused.\n\n\n\n\n\n\nIdentify who is responsible for leading each topic\n. Someone\n  other than the formal meeting leader is often responsible for\n  leading the discussion of a particular agenda item. This person may\n  be providing context for the topic, explaining data, or may have\n  organizational responsibility for that area.  Identifying this\n  person next to the agenda item ensures that anyone who is\n  responsible for leading part of the agenda knows it -- and prepares\n  for it -- before the meeting.\n\n\n\n\n\n\nRecap decisions and actions just before the meeting ends\n. For\n  productive meetings, the end is just as important as the\n  beginning. Don't let people leave the meeting in silent\n  disagreement.\n\n\n\n\n\n\nFollow up\n. It's quite common for people to come away from the\n  same meeting with very different interpretations of what went on. To\n  reduce this risk, use Trello to highlight what was accomplished to\n  all who attended, document the responsibilities given, tasks\n  delegated, and any assigned deadlines.  This way, everyone will be\n  on the same page.\n\n\n\n\n\n\nWeekly Meetings\n\n\nAt talPor we use weekly meetings to keep track of the progress of each\nproject.  Ideally these meetings happen every week, at the same day,\nat the same time and are split into three meetings.\n\n\nPre-meeting\n\n\nThis meeting is just for the development team, it usually happens just\nbefore meeting with the client. The key objective here is to make sure\nthat the team is on the same page with the line of communication that\nis going to be delivered to the client.  It's important that everyone\nis clear about what you will and won't say as well as how things will\nbe presented. Take time to prepare strategies to confront possible\nproblems or difficult situations that could arise during the next\nmeeting. Use the shared agenda with the client to make sure that you\ncan handle all the points reflected there. After the \"Pre-meeting\" the\nteam has to be able to explain the progress of the week, give feedback\nrelated to the overall scope of the project and have a proposal of\nwhat is going to be the focus of the next week.\n\n\nClient Meeting\n\n\nAt this point the client joins the development team and the idea is to\nanswer the following questions\n\n\n\n\nWhat was last week's progress?\n\n\nDid we fulfill the expectations the team had? If we didn't,\n    explain why and how does that affects our schedule.\n\n\nHow are we in regards to our schedule?\n\n\nAre we meeting any particular deadline established with the\n    client?\n\n\nIs there any change in the scope of the project?\n\n\nWhat is going to be the expectation for the next week?\n\n\n\n\nThis meeting is definitely key in the relationship with the clients,\nbut it's important to maintain constant communication with them over\nthe week to show any progress, because if we use this meeting to show\nnew features the meeting is going to take a long time.\n\n\nSlack\n is your best tool for constant and effective communication.\n\n\nKeep the project's \nTrello\n board updated and do your best to engage\nthe client there to receive as much feedback as possible before the\nmeeting.\n\n\nPost-meeting\n\n\nThis happens immediately after the meeting with the client and is just\nfor the development team. The goal is to make sure that everyone knows\ntheir respective responsibilities. Use this time to update Trello\naccording to the feedback received in the previous meeting.", 
            "title": "Meetings"
        }, 
        {
            "location": "/development/methodology/meetings/#meetings", 
            "text": "Meetings are very important in the development process as they ensure\nthat everybody is on the same page and is one of the primary ways to\ngive and receive feedback to and from our clients. But, at the same\ntime, meetings can become a painful process where the team feels that\nit's losing valuable time.  Meeting tips  Before digging in to the particular process that we use at talPor, it\nwould be useful to keep some tips in mind to transform meetings into a\nproductive tool and a competitive advantage:    Start on time and finish on time . People appreciate it when you\n  understand that their time is valuable. Another note on time: Do not\n  schedule any meetings to last longer than an hour. Sixty minutes is\n  generally the longest time workers can remain truly engaged.    Stick to your schedule . Create an agenda that lays out\n  everything you plan to cover in the meeting. Once you're in the\n  meeting, put that agenda somewhere accessible for everyone (Trello\n  is a great alternative) and guide the flow of the meeting according\n  to the points that are reflected there. This keeps people focused.    Identify who is responsible for leading each topic . Someone\n  other than the formal meeting leader is often responsible for\n  leading the discussion of a particular agenda item. This person may\n  be providing context for the topic, explaining data, or may have\n  organizational responsibility for that area.  Identifying this\n  person next to the agenda item ensures that anyone who is\n  responsible for leading part of the agenda knows it -- and prepares\n  for it -- before the meeting.    Recap decisions and actions just before the meeting ends . For\n  productive meetings, the end is just as important as the\n  beginning. Don't let people leave the meeting in silent\n  disagreement.    Follow up . It's quite common for people to come away from the\n  same meeting with very different interpretations of what went on. To\n  reduce this risk, use Trello to highlight what was accomplished to\n  all who attended, document the responsibilities given, tasks\n  delegated, and any assigned deadlines.  This way, everyone will be\n  on the same page.    Weekly Meetings  At talPor we use weekly meetings to keep track of the progress of each\nproject.  Ideally these meetings happen every week, at the same day,\nat the same time and are split into three meetings.  Pre-meeting  This meeting is just for the development team, it usually happens just\nbefore meeting with the client. The key objective here is to make sure\nthat the team is on the same page with the line of communication that\nis going to be delivered to the client.  It's important that everyone\nis clear about what you will and won't say as well as how things will\nbe presented. Take time to prepare strategies to confront possible\nproblems or difficult situations that could arise during the next\nmeeting. Use the shared agenda with the client to make sure that you\ncan handle all the points reflected there. After the \"Pre-meeting\" the\nteam has to be able to explain the progress of the week, give feedback\nrelated to the overall scope of the project and have a proposal of\nwhat is going to be the focus of the next week.  Client Meeting  At this point the client joins the development team and the idea is to\nanswer the following questions   What was last week's progress?  Did we fulfill the expectations the team had? If we didn't,\n    explain why and how does that affects our schedule.  How are we in regards to our schedule?  Are we meeting any particular deadline established with the\n    client?  Is there any change in the scope of the project?  What is going to be the expectation for the next week?   This meeting is definitely key in the relationship with the clients,\nbut it's important to maintain constant communication with them over\nthe week to show any progress, because if we use this meeting to show\nnew features the meeting is going to take a long time.  Slack  is your best tool for constant and effective communication.  Keep the project's  Trello  board updated and do your best to engage\nthe client there to receive as much feedback as possible before the\nmeeting.  Post-meeting  This happens immediately after the meeting with the client and is just\nfor the development team. The goal is to make sure that everyone knows\ntheir respective responsibilities. Use this time to update Trello\naccording to the feedback received in the previous meeting.", 
            "title": "Meetings"
        }, 
        {
            "location": "/development/methodology/trello/", 
            "text": "\ufeffTrello\n\n\nThis section will define how we should be using Trello in our\nprojects.\n\n\nNaming of Cards (US, Tasks)\n\n\nThe name of the card should contain a user story that somebody will,\neventually, have to do. This should be obtained from the requirements\nthat the client has specified previously.\n\n\nThe name of the card should be short but it needs to explain what\nneeds to be done. If there is some extra information that is needed\nto fully understand the task it should be written down in the description\nof the card. In the same spirit, if a document exists that is related to \nthe task, it should be attached to the card so the person responsible \nof working on the task can easily access it.\n\n\nIn order to track the work being done on a user story, checklists\nshould be used inside the card to keep track of the actual tasks that\nneed to be done. When a particular task is completed, it should be\nmarked as such in the task checklist, so Trello can display the\npercentage of completion for the whole card.\n\n\nIdeally, work on a card shouldn't be split over the span of multiple\nweeks. As such, the \"actual effort\" that has been poured into a user\nstory should be tracked in the task. More information about this below\non the \nDoing\n list. The general motivation for this is calculating\nthe differential between what we have previously estimated and the\nactual effort that we do. At the end of the week, this differential is\nthe number of story points that get carried over the next week, in\nthe case of a card that wasn't completed.\n\n\nThose tasks that are not part of a user story, like sysadmin stuff,\nshould also be tracked using a card. We suggest using a label so they\ncan be easily identified. The color suggested to identify this kind of\ncards is blue.\n\n\nUse of Trello in Weekly Meetings\n\n\nTrello is the main way in which we communicate to the client\nwhat we are currently doing, what we did and what we are going to do\nin the future. This means that we need to keep it up to date and\ninform the client that he can keep an eye on the project at any moment\njust by looking at the cards on Trello.\n\n\nBefore every meeting we need to look at what is in Trello and what is\nthe status of every card so we can give a correct information about\nthe project to the client. Use Trello to write the agenda of the\nmeeting, in this way everybody can see what has happened in the\nprevious meetings in an easy way. Also write in the agenda those\naspects that come out during the meeting, as well as those aspects\nthat need to be done that aren't necessary a task.\n\n\nDuring the meeting you need to inform the client about the status of\nTrello, which should also be the current status of the project. Let\nthe client ask questions about the cards, and answer any doubts that\ncome up. After the meeting you need to update Trello to reflect what\nis going to be done in the next iteration and estimate the\ncorresponding cards.\n\n\nLists and meaning of lists\n\n\n1. \nBacklog:\n\n\nEvery task that regarding the project should be here. \nIf a task is\nnot in the backlog (or any other list) it doesn't exist\n. Any idea,\nany \"nice to have\" feature, everything that should be included in the\nproduct at any point in the development, should be there, so everybody\ncan track what things are left to be completed on the project. The\neventual bugs that are found in the project should also be created in\nthis list and must be marked with a \nBUG\n label. We additionally\nsuggest using the red label to identify bug cards, so they can be\neasily triaged.\n\n\n2. \nToDo:\n\n\nThis list should have the tasks that are going to be worked on the\ncurrent iteration. Those tasks should have been estimated in order to\nbe certain that the iteration can be completed on time.\n\n\n3. \nDoing:\n\n\nAs soon as you begin working on a task you should move it from \"ToDo\" to\n\"Doing\" as this helps the team and the client to know what the current\nstatus of the iteration is, as well as what things the team is\ncurrently working on.\n\n\nAs development on the card advances, you need to tag the title of the\ncard by adding the number of story points of effort dedicated to the\ncard, wrapped in brackets ( \n[ ]\n, i.e. \n[8]\n). For example, if\ntwo days of work have been devoted to a card estimated to take 8 story\npoints and named \"\n(8) As a user I want to login\n\", you should\nupdate it to \"\n(8) As a user I want to login [4]\n\". This should be\ndone at the end of each week for all cards for which development has\nstarted or ended during that week.\n\n\nThis process is vital and should never be skipped since it provides\nimportant data about how effectively the team is estimating cards and\nit allows the splitting of cards over the span of several weeks.\n\n\n4. \nPending Review (optional, to be reviewed by another dev):\n\n\nThe general idea behind this list is to add a step of quality\nassurance of the software that we are building. There are some things\nthat the client can't or doesn't want to test. These things should be\ntested by a developer different from the one responsible for the\ntask. This is optional, as it depends of various factors, for example,\nif the team is bigger than one developer and if there is time planned\nin the iteration to do these tests.\n\n\n5. \nTo be tested (to be reviewed and approved by the client):\n\n\nThese tests are known as \"Acceptance Tests\". The client is the only\none who knows what he really wants, so it's up to him to decide if the\nfeature that we build satisfies his needs. Sometimes the client\ndoesn't want to do the tests in the staging server, but it is really\nimportant to make him understand that this is the only way that we can\nbe sure that we are on track and building the right product.\n\n\n6. \nApproved (Ready to Deploy):\n\n\nOnce the client performs the tests related to a card, he lets the team\nknow that the card is approved by moving it from the \"To be tested\"\nlist to the \"Approved\" list. \nOnly the client can move the cards to\nthis list (unless, of course, there is a previous agreement that\nanother person can do it)\n. The cards on this list can be deployed\ninto production when needed.\n\n\n\n\n\n\nCode is implemented and working.\n\n\n\n\n\n\nTests are written and passes.\n\n\n\n\n\n\nCode is live in the development (or staging) server.\n\n\n\n\n\n\n7. \nDone:\n\n\nThis list should have the cards that are approved by the client and\nare already in the production server. After the client approves the\ncard, the person responsible of making the production deploy should\nput the card in this list as soon as he finishes the deploy (The\nfeatures should be\n\n\"\nsmoke tested\n\"\n\nto be sure that everything is OK).\n\n\n\n\n\n\nTask was in Approved (ready for deploy).\n\n\n\n\n\n\nAcceptance test have been carried out by the client.\n\n\n\n\n\n\nCode is in production environment.\n\n\n\n\n\n\nReview the \nDefinition of Done\n section\nfor further information.\n\n\n8. \nAgenda:\n\n\nIn this list every card represents a meeting. Those cards contain the\ninformation about the points that were discussed in the meeting. The\nname of the card is the date in which the meeting occurs.  Use a\nchecklist to show the points to be discussed. Use the description to\nannotate any information relevant about the points of the meetings.\nYou can attach documents or make comments about the meeting using the\ncorresponding feature in Trello.  These cards should be created before\nthe meeting with the client, preferably during the team's pre-meeting.\n\n\nTips\n\n\nRemember that a tool is only useful if everyone uses it. Due to the\nfact that we are not in the same place, we strongly depend on these\nkind of tools to be able to do our job in the best possible way. Do\nnot hesitate to bring in new insights about how we can improve the way\nwe use Trello or if there is another tool that can replace this and\nmake our life easier.", 
            "title": "Trello"
        }, 
        {
            "location": "/development/methodology/trello/#trello", 
            "text": "This section will define how we should be using Trello in our\nprojects.  Naming of Cards (US, Tasks)  The name of the card should contain a user story that somebody will,\neventually, have to do. This should be obtained from the requirements\nthat the client has specified previously.  The name of the card should be short but it needs to explain what\nneeds to be done. If there is some extra information that is needed\nto fully understand the task it should be written down in the description\nof the card. In the same spirit, if a document exists that is related to \nthe task, it should be attached to the card so the person responsible \nof working on the task can easily access it.  In order to track the work being done on a user story, checklists\nshould be used inside the card to keep track of the actual tasks that\nneed to be done. When a particular task is completed, it should be\nmarked as such in the task checklist, so Trello can display the\npercentage of completion for the whole card.  Ideally, work on a card shouldn't be split over the span of multiple\nweeks. As such, the \"actual effort\" that has been poured into a user\nstory should be tracked in the task. More information about this below\non the  Doing  list. The general motivation for this is calculating\nthe differential between what we have previously estimated and the\nactual effort that we do. At the end of the week, this differential is\nthe number of story points that get carried over the next week, in\nthe case of a card that wasn't completed.  Those tasks that are not part of a user story, like sysadmin stuff,\nshould also be tracked using a card. We suggest using a label so they\ncan be easily identified. The color suggested to identify this kind of\ncards is blue.  Use of Trello in Weekly Meetings  Trello is the main way in which we communicate to the client\nwhat we are currently doing, what we did and what we are going to do\nin the future. This means that we need to keep it up to date and\ninform the client that he can keep an eye on the project at any moment\njust by looking at the cards on Trello.  Before every meeting we need to look at what is in Trello and what is\nthe status of every card so we can give a correct information about\nthe project to the client. Use Trello to write the agenda of the\nmeeting, in this way everybody can see what has happened in the\nprevious meetings in an easy way. Also write in the agenda those\naspects that come out during the meeting, as well as those aspects\nthat need to be done that aren't necessary a task.  During the meeting you need to inform the client about the status of\nTrello, which should also be the current status of the project. Let\nthe client ask questions about the cards, and answer any doubts that\ncome up. After the meeting you need to update Trello to reflect what\nis going to be done in the next iteration and estimate the\ncorresponding cards.  Lists and meaning of lists  1.  Backlog:  Every task that regarding the project should be here.  If a task is\nnot in the backlog (or any other list) it doesn't exist . Any idea,\nany \"nice to have\" feature, everything that should be included in the\nproduct at any point in the development, should be there, so everybody\ncan track what things are left to be completed on the project. The\neventual bugs that are found in the project should also be created in\nthis list and must be marked with a  BUG  label. We additionally\nsuggest using the red label to identify bug cards, so they can be\neasily triaged.  2.  ToDo:  This list should have the tasks that are going to be worked on the\ncurrent iteration. Those tasks should have been estimated in order to\nbe certain that the iteration can be completed on time.  3.  Doing:  As soon as you begin working on a task you should move it from \"ToDo\" to\n\"Doing\" as this helps the team and the client to know what the current\nstatus of the iteration is, as well as what things the team is\ncurrently working on.  As development on the card advances, you need to tag the title of the\ncard by adding the number of story points of effort dedicated to the\ncard, wrapped in brackets (  [ ] , i.e.  [8] ). For example, if\ntwo days of work have been devoted to a card estimated to take 8 story\npoints and named \" (8) As a user I want to login \", you should\nupdate it to \" (8) As a user I want to login [4] \". This should be\ndone at the end of each week for all cards for which development has\nstarted or ended during that week.  This process is vital and should never be skipped since it provides\nimportant data about how effectively the team is estimating cards and\nit allows the splitting of cards over the span of several weeks.  4.  Pending Review (optional, to be reviewed by another dev):  The general idea behind this list is to add a step of quality\nassurance of the software that we are building. There are some things\nthat the client can't or doesn't want to test. These things should be\ntested by a developer different from the one responsible for the\ntask. This is optional, as it depends of various factors, for example,\nif the team is bigger than one developer and if there is time planned\nin the iteration to do these tests.  5.  To be tested (to be reviewed and approved by the client):  These tests are known as \"Acceptance Tests\". The client is the only\none who knows what he really wants, so it's up to him to decide if the\nfeature that we build satisfies his needs. Sometimes the client\ndoesn't want to do the tests in the staging server, but it is really\nimportant to make him understand that this is the only way that we can\nbe sure that we are on track and building the right product.  6.  Approved (Ready to Deploy):  Once the client performs the tests related to a card, he lets the team\nknow that the card is approved by moving it from the \"To be tested\"\nlist to the \"Approved\" list.  Only the client can move the cards to\nthis list (unless, of course, there is a previous agreement that\nanother person can do it) . The cards on this list can be deployed\ninto production when needed.    Code is implemented and working.    Tests are written and passes.    Code is live in the development (or staging) server.    7.  Done:  This list should have the cards that are approved by the client and\nare already in the production server. After the client approves the\ncard, the person responsible of making the production deploy should\nput the card in this list as soon as he finishes the deploy (The\nfeatures should be \" smoke tested \" \nto be sure that everything is OK).    Task was in Approved (ready for deploy).    Acceptance test have been carried out by the client.    Code is in production environment.    Review the  Definition of Done  section\nfor further information.  8.  Agenda:  In this list every card represents a meeting. Those cards contain the\ninformation about the points that were discussed in the meeting. The\nname of the card is the date in which the meeting occurs.  Use a\nchecklist to show the points to be discussed. Use the description to\nannotate any information relevant about the points of the meetings.\nYou can attach documents or make comments about the meeting using the\ncorresponding feature in Trello.  These cards should be created before\nthe meeting with the client, preferably during the team's pre-meeting.  Tips  Remember that a tool is only useful if everyone uses it. Due to the\nfact that we are not in the same place, we strongly depend on these\nkind of tools to be able to do our job in the best possible way. Do\nnot hesitate to bring in new insights about how we can improve the way\nwe use Trello or if there is another tool that can replace this and\nmake our life easier.", 
            "title": "\ufeffTrello"
        }, 
        {
            "location": "/development/methodology/done/", 
            "text": "Definition of done\n\n\nThe Definition of done is a concept extracted from the Agile Scrum\nmethodology, and it's crucial to a highly functioning agile team. It's\ndefined as a set of criteria or checklist that should be met before a\nfeature (usually a task or a User Story) is considered \nDone\n. With\nthis in mind, everyone that is involved with the team will have a\ncommon understanding of \"what's done\". It should be taken into account\nthat a feature should be considered done when it is a \"potentially\nshippable\" feature or it's ready to be released.\n\n\nCurrently, we use the following criteria to specify if a feature is\ndone:\n\n\n\n\nThe code for the featured was produced.\n\n\nTests written and passing.\n\n\nThe code is commited and pushed to the development repository.\n\n\nThe code is live in the development server.\n\n\nAcceptance tests have been carried out by the client.\n\n\nCode is merged and pushed into Production environment.\n\n\nCode is live into production environment.\n\n\n\n\n\n\nEvery task or feature must comply with the definition of done before\nconsider it finished!", 
            "title": "Definition of Done"
        }, 
        {
            "location": "/development/methodology/done/#definition-of-done", 
            "text": "The Definition of done is a concept extracted from the Agile Scrum\nmethodology, and it's crucial to a highly functioning agile team. It's\ndefined as a set of criteria or checklist that should be met before a\nfeature (usually a task or a User Story) is considered  Done . With\nthis in mind, everyone that is involved with the team will have a\ncommon understanding of \"what's done\". It should be taken into account\nthat a feature should be considered done when it is a \"potentially\nshippable\" feature or it's ready to be released.  Currently, we use the following criteria to specify if a feature is\ndone:   The code for the featured was produced.  Tests written and passing.  The code is commited and pushed to the development repository.  The code is live in the development server.  Acceptance tests have been carried out by the client.  Code is merged and pushed into Production environment.  Code is live into production environment.    Every task or feature must comply with the definition of done before\nconsider it finished!", 
            "title": "Definition of done"
        }, 
        {
            "location": "/development/methodology/retrospective/", 
            "text": "The Process\n\n\nDuring a project's life it's important to evaluate, inspect and adapt \nthe applied methods and teamwork. The \nRetrospective\n is a process \nused to gather feedback about a project not just in technical terms \nbut in the team and team issues.\n\n\n\n\nRetrospectives\n enables whole-team learning, act as catalysts for \nchange, and generate action.\n\nAgile retrospectives, Esther Derby, Diana Larsen\n\n\n\n\nThis process is done through a \nRetrospective Meeting\n where the team gathers\nto discuss about the project. This meeting is meant to be carried \nout periodically, in talPor, we do \nmonthly\n \nRestrospective Meetings\n and\nwe apply several of the retrospectives techniques described in the book\n\nAgile retrospectives by Esther Derby, Diana Larsen\n. \n\n\nFor the retrospective meetings there's usually one person in charge of \nleading it, for Scrum this person would be the \nScrum Master\n. However,\nin our case, since we have small teams and we want to evaluate the whole\nteam, we include one person from a different team to lead the process. \nWe also do this because the presence of a person that is not familiarized \nwith the project gives us an objective point of view to the meeting which \ncan lead us to discover problems that the members of the team didn't recognize. \n\n\nAt the end of the retrospective meeting we obtain a set of identified issues\nwhich we classify as \nThings to improve\n, \nThings to be kept\n and \n\nThings to be removed\n.\n\n\nThe Retrospective Meeting\n\n\nIn this section we'll describe as detail as possible the process we use to \ncarry out the meeting.  As we explained above, we use some of the techniques\ndescribes in the \nAgile retrospectives\n books to carry out the meeting. It's\nimportant that the person in charge of the meeting prepare a little bit beforehand\nin oder to prevent improvisation during the meeting. Also, it's important to \napply different techniques and to vary the activities, the retrospective should \nnot become a boring and repetitive activity, otherwise, you'll end up optaining \nmeaningless outcomes.\n\n\nThe most important thing is to evaluate the state of the team and the context in\nwhich it is developing in order to select the correct type of activities to be\napplied during he meeting. This means, you should evaluate if the team needs to\ndiscover failures, if you want to know what's the root of one or some problems,\nif you have identified that there are problems between some team members, etc.\n\n\nThe activities to be selected for the retrospective meeting should be inclined \ntowards the context of the team, as explained above. \n\n\nThe retrospective meeting is usually structured in the following form:\n\n\n\n\n\n\nSet the stage:\n In this stage the retrospective leader sets the goals and the\ncommon ground of the meeting. This helps people focus on the work at hand, to\nundestand the goals and how they will spend their time. \n\n\n\n\n\n\nGather data:\n Not all the participants involved in the retrospective have the\nsame point of view, have been present in all the iteration days nor see the same.\nThat's why gathering data about what's happened during the iteration is important\nto have a general picture so that everyone are in the same page.\n\n\n\n\n\n\nGenerate insights:\n In this phase the team identifies the strengths and issues\nabout the iteration. It's the moment to ask \nWhy?\n, identify causes and effects,\nconsider different possibilities and think about them analitically.\n\n\n\n\n\n\nDecide what to do:\n At this point the team should have a list of potential\nexperiments and improvements. Sometimes you can come up with a lot of improvements\nand things to do, but it's recommended to select a realistic subset of those - What \nyou consider the most relevant - and work with those for the next iteration.\n\n\n\n\n\n\nClose the retrospective:\n In this phase you decide how to document the retrospective\nand plan a follow-up. It's important for the team to retain the learning outcome from\nthe retrospective and apply it successfully.\n\n\n\n\n\n\nExample of our Retrospective\n\n\nAs a base start for a retrospective, we have selected some activities which we'll \nexplain below. These activities were selected for the first retrospective of a \nstarted project which had more than 3 months of development, so we wanted to focus \non getting and overview of what was going on with it.\n\n\nSince we are a highly distributed team not all the team members where in the same \nplace geographicall. For that we used a tool called \n\nReal Time Board\n to maintain the real time dynamic \nof the \nRetrospective Meeting\n.\n\n\nWe selected the following set of activities from the \nAgile Retrospectives\n book\nfor the meeting:\n\n\n\n\n\n\nSet the Stage\n\n\n\n\nCheck-in and Working agreement:\n We started setting the ground rules and \nremembering our [Guiding principles] (/talpor-dev-handbook/#the-guiding-principles).\n\n\n\n\n\n\n\n\nGather data\n\n\n\n\nTimeline with color coding events and dot voting:\n This was our first \nretrospective, so we wanted to identify all the relevant events of the \nproject's life and categorize them. Also, we voted if the event was positive \nor negative for the project.\n\n\n\n\n\n\n\n\nGenerate Insights\n\n\n\n\nPatterns and shift:\n We discussed the events generated in the timeline and \nanalyzed them trying to find patterns and possible causes. As outcome we obtained \na list of actions.\n\n\n\n\n\n\n\n\nDecide what to do\n\n\n\n\nPrioritize with dots:\n Based on the obtained list, we dot voted the actions to \ntake and classified them as \nThings to improve\n, \nThings to be kept\n and \n\nThings to be removed\n.\n\n\n\n\n\n\n\n\nClose the retrospective\n\n\n\n\n+/Delta\n: We analyzed the retrospective process looking for strengths and \npossible improvements for the next retrospective.\n\n\n\n\n\n\n\n\nAn example of the board we used for this retrospective can be found \n\nhere\n. It's important to notice \nthat you'll need permissions to access this board.", 
            "title": "Retrospective"
        }, 
        {
            "location": "/development/methodology/retrospective/#the-process", 
            "text": "During a project's life it's important to evaluate, inspect and adapt \nthe applied methods and teamwork. The  Retrospective  is a process \nused to gather feedback about a project not just in technical terms \nbut in the team and team issues.   Retrospectives  enables whole-team learning, act as catalysts for \nchange, and generate action. Agile retrospectives, Esther Derby, Diana Larsen   This process is done through a  Retrospective Meeting  where the team gathers\nto discuss about the project. This meeting is meant to be carried \nout periodically, in talPor, we do  monthly   Restrospective Meetings  and\nwe apply several of the retrospectives techniques described in the book Agile retrospectives by Esther Derby, Diana Larsen .   For the retrospective meetings there's usually one person in charge of \nleading it, for Scrum this person would be the  Scrum Master . However,\nin our case, since we have small teams and we want to evaluate the whole\nteam, we include one person from a different team to lead the process. \nWe also do this because the presence of a person that is not familiarized \nwith the project gives us an objective point of view to the meeting which \ncan lead us to discover problems that the members of the team didn't recognize.   At the end of the retrospective meeting we obtain a set of identified issues\nwhich we classify as  Things to improve ,  Things to be kept  and  Things to be removed .", 
            "title": "The Process"
        }, 
        {
            "location": "/development/methodology/retrospective/#the-retrospective-meeting", 
            "text": "In this section we'll describe as detail as possible the process we use to \ncarry out the meeting.  As we explained above, we use some of the techniques\ndescribes in the  Agile retrospectives  books to carry out the meeting. It's\nimportant that the person in charge of the meeting prepare a little bit beforehand\nin oder to prevent improvisation during the meeting. Also, it's important to \napply different techniques and to vary the activities, the retrospective should \nnot become a boring and repetitive activity, otherwise, you'll end up optaining \nmeaningless outcomes.  The most important thing is to evaluate the state of the team and the context in\nwhich it is developing in order to select the correct type of activities to be\napplied during he meeting. This means, you should evaluate if the team needs to\ndiscover failures, if you want to know what's the root of one or some problems,\nif you have identified that there are problems between some team members, etc.  The activities to be selected for the retrospective meeting should be inclined \ntowards the context of the team, as explained above.   The retrospective meeting is usually structured in the following form:    Set the stage:  In this stage the retrospective leader sets the goals and the\ncommon ground of the meeting. This helps people focus on the work at hand, to\nundestand the goals and how they will spend their time.     Gather data:  Not all the participants involved in the retrospective have the\nsame point of view, have been present in all the iteration days nor see the same.\nThat's why gathering data about what's happened during the iteration is important\nto have a general picture so that everyone are in the same page.    Generate insights:  In this phase the team identifies the strengths and issues\nabout the iteration. It's the moment to ask  Why? , identify causes and effects,\nconsider different possibilities and think about them analitically.    Decide what to do:  At this point the team should have a list of potential\nexperiments and improvements. Sometimes you can come up with a lot of improvements\nand things to do, but it's recommended to select a realistic subset of those - What \nyou consider the most relevant - and work with those for the next iteration.    Close the retrospective:  In this phase you decide how to document the retrospective\nand plan a follow-up. It's important for the team to retain the learning outcome from\nthe retrospective and apply it successfully.", 
            "title": "The Retrospective Meeting"
        }, 
        {
            "location": "/development/methodology/retrospective/#example-of-our-retrospective", 
            "text": "As a base start for a retrospective, we have selected some activities which we'll \nexplain below. These activities were selected for the first retrospective of a \nstarted project which had more than 3 months of development, so we wanted to focus \non getting and overview of what was going on with it.  Since we are a highly distributed team not all the team members where in the same \nplace geographicall. For that we used a tool called  Real Time Board  to maintain the real time dynamic \nof the  Retrospective Meeting .  We selected the following set of activities from the  Agile Retrospectives  book\nfor the meeting:    Set the Stage   Check-in and Working agreement:  We started setting the ground rules and \nremembering our [Guiding principles] (/talpor-dev-handbook/#the-guiding-principles).     Gather data   Timeline with color coding events and dot voting:  This was our first \nretrospective, so we wanted to identify all the relevant events of the \nproject's life and categorize them. Also, we voted if the event was positive \nor negative for the project.     Generate Insights   Patterns and shift:  We discussed the events generated in the timeline and \nanalyzed them trying to find patterns and possible causes. As outcome we obtained \na list of actions.     Decide what to do   Prioritize with dots:  Based on the obtained list, we dot voted the actions to \ntake and classified them as  Things to improve ,  Things to be kept  and  Things to be removed .     Close the retrospective   +/Delta : We analyzed the retrospective process looking for strengths and \npossible improvements for the next retrospective.     An example of the board we used for this retrospective can be found  here . It's important to notice \nthat you'll need permissions to access this board.", 
            "title": "Example of our Retrospective"
        }, 
        {
            "location": "/development/methodology/post-mortem/", 
            "text": "The process\n\n\nAt the end of a project cycle or when somebody gets out of the\nproject, we run a \nPost-mortem\n or \nLessons learned\n process.\n\n\nThe \nPost-mortem\n is a valuable tool to ensure continuous\nimprovement for a software development team. Although its name seems\nforbidding, it's just a process to assess how a project went. Some\npeople prefer to call it a \nRetrospective\n instead because\n\nPost-mortem\n seems to be a negative term that implies the death of a\nproject.\n\n\nIn our case, we will stick to \nPost-mortem\n or \nLessons learned\n since\nwe actually run several retrospectives during the project's lifespan and\nthey have different approaches and goals than the ones being described\nhere.\n\n\nIn talPor \nPost-mortems\n are carried out in two phases. The first one\nis individual to every member of the project and consists in filling\nin a \nPost-mortem report\n. Each project member provides his own\nreflection and assessment about the overall project arc in a way that\nwe can discover what went well and what could have been done better\nnext time around. The ultimate goal is \"lessons learned\" \u2014 a set of\nactionable ideas for improving the next project.\n\n\nThe second phase consists in a \nPost-mortem meeting\n. This is where\nthe different reported outcomes are discussed and conclusions and\n\"lessons learned\" are drawn.\n\n\nThere are two different scenarios where the \nPost-mortems\n are applied:\n\n\n\n\nA team member gets out of the project.\n\n\nThe project cycle ends or the project is finished.\n\n\n\n\nFor each scenario there is a different course of action. If a \nmember\nleaves the team\n his post-mortem report will be evaluated in the\nfollowing \nRetrospective meeting\n. In this case, the retrospective\nmeeting will consists on the post-mortem evaluation as the first task,\nfrom which the outcomes will be used as input for the current\nretrospective where the ex-member is not bound to participate. In the\ncase where the \nproject cycle ends or the project is finished\n we\norganize a \nPost-mortem meeting\n as described before.\n\n\nPost-mortem report\n\n\nThe purpose of the project's Post-mortem Report is to record, in\ndetail, the specific project activities that were most effective and\nthose that require adjustments for future projects. It could be seen\nas an overall reflection of what's been going on with the project. The\nobjective of this report is to inform the development teams about\nthose important lessons learned during the development of the project\n(i.e. obstacles, challenges, successes, what could be done differently\nnext time, etc.), in a way that we can avoid making the same mistakes\nand learn from them.\n\n\nIn talPor we have a custom post-mortem report template that is used to\ngather this information. This template is sent as a Google\nquestionnaire and its answers are stored in a google spreadsheet. You\ncan make a copy of this\n\nquestionnaire\n\nfor your project in order to carry out your own post-mortem process.\n\n\nPost-mortem meeting\n\n\nAfter all the post-mortem reports have been filled in, it's time to\ndiscuss and draw some team conclusions about the project. Once\neveryone has written the \npost-mortem report\n we are on the same page\nto discuss and derive some lessons learned about the process of the\nproject.\n\n\nThe meeting has to be scheduled as soon as all the post-mortem reports\nhave been filled and handed in. According to the following cases the\nmeeting will have different formats:\n\n\n\n\n\n\nOne member leaves the team\n: In this case, the post-mortem\n   report of the one who left will be discussed during the next\n   \nretrospective\n meeting of the project. At the beginning of the\n   retrospective meeting, the post-mortem report of this member is\n   discussed and the conclusions of that discussion will feed the\n   retrospective meeting that will be carried out. It's not necessary\n   that this member participates in the entire retrospective meeting\n   as he doesn't belong to the team anymore.\n\n\n\n\n\n\nThe project finishes or closes\n: A post-mortem meeting is set up\n   in this case and no more retrospective meetings are carried out. In\n   this meeting the results of each post-mortem report are discussed\n   and some conclusions and lessons learned are drawn.", 
            "title": "Post-Mortem"
        }, 
        {
            "location": "/development/methodology/post-mortem/#the-process", 
            "text": "At the end of a project cycle or when somebody gets out of the\nproject, we run a  Post-mortem  or  Lessons learned  process.  The  Post-mortem  is a valuable tool to ensure continuous\nimprovement for a software development team. Although its name seems\nforbidding, it's just a process to assess how a project went. Some\npeople prefer to call it a  Retrospective  instead because Post-mortem  seems to be a negative term that implies the death of a\nproject.  In our case, we will stick to  Post-mortem  or  Lessons learned  since\nwe actually run several retrospectives during the project's lifespan and\nthey have different approaches and goals than the ones being described\nhere.  In talPor  Post-mortems  are carried out in two phases. The first one\nis individual to every member of the project and consists in filling\nin a  Post-mortem report . Each project member provides his own\nreflection and assessment about the overall project arc in a way that\nwe can discover what went well and what could have been done better\nnext time around. The ultimate goal is \"lessons learned\" \u2014 a set of\nactionable ideas for improving the next project.  The second phase consists in a  Post-mortem meeting . This is where\nthe different reported outcomes are discussed and conclusions and\n\"lessons learned\" are drawn.  There are two different scenarios where the  Post-mortems  are applied:   A team member gets out of the project.  The project cycle ends or the project is finished.   For each scenario there is a different course of action. If a  member\nleaves the team  his post-mortem report will be evaluated in the\nfollowing  Retrospective meeting . In this case, the retrospective\nmeeting will consists on the post-mortem evaluation as the first task,\nfrom which the outcomes will be used as input for the current\nretrospective where the ex-member is not bound to participate. In the\ncase where the  project cycle ends or the project is finished  we\norganize a  Post-mortem meeting  as described before.  Post-mortem report  The purpose of the project's Post-mortem Report is to record, in\ndetail, the specific project activities that were most effective and\nthose that require adjustments for future projects. It could be seen\nas an overall reflection of what's been going on with the project. The\nobjective of this report is to inform the development teams about\nthose important lessons learned during the development of the project\n(i.e. obstacles, challenges, successes, what could be done differently\nnext time, etc.), in a way that we can avoid making the same mistakes\nand learn from them.  In talPor we have a custom post-mortem report template that is used to\ngather this information. This template is sent as a Google\nquestionnaire and its answers are stored in a google spreadsheet. You\ncan make a copy of this questionnaire \nfor your project in order to carry out your own post-mortem process.  Post-mortem meeting  After all the post-mortem reports have been filled in, it's time to\ndiscuss and draw some team conclusions about the project. Once\neveryone has written the  post-mortem report  we are on the same page\nto discuss and derive some lessons learned about the process of the\nproject.  The meeting has to be scheduled as soon as all the post-mortem reports\nhave been filled and handed in. According to the following cases the\nmeeting will have different formats:    One member leaves the team : In this case, the post-mortem\n   report of the one who left will be discussed during the next\n    retrospective  meeting of the project. At the beginning of the\n   retrospective meeting, the post-mortem report of this member is\n   discussed and the conclusions of that discussion will feed the\n   retrospective meeting that will be carried out. It's not necessary\n   that this member participates in the entire retrospective meeting\n   as he doesn't belong to the team anymore.    The project finishes or closes : A post-mortem meeting is set up\n   in this case and no more retrospective meetings are carried out. In\n   this meeting the results of each post-mortem report are discussed\n   and some conclusions and lessons learned are drawn.", 
            "title": "The process"
        }, 
        {
            "location": "/development/tech/", 
            "text": "Tech Standards\n\n\nSource Control\n\n\nFrom the get go, use version control. This is not negotiable. At\ntalPor we use \nGit\n exclusively. For open source code,\nwe publish at \nGitHub\n and for everything else we use\ninternal Git repositories.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nDon't rewrite public story!\n Bad stuff happens when you do that,\n    kittens die. Just don't do it.\n\n\n\n\n\n\nTry to make your commits as atomic as possible. If you feel like you\n  have many commits that don't quite work up to a feature (which you\n  have not yet pushed), you can squash them with a rebase.\n\n\n\n\n\n\nFollow\n  \nGit Flow\n. However,\n  we keep master as develop, and production as master. Use feature and\n  hotfix branches. There are also a set of Git extensions made by nvie that\n  can be used to work with this pattern easily, get it \nhere\n.\n\n\n\n\n\n\nWrite good commit messages. Use a good headline and, if needed,\n  follow it by further details about the commit.\n\n\n\n\n\n\nCherish the existence of \ncherry-pick\n and \nbisect\n. Learn how and when\n  to use \nrebase\n and \nreset\n.\n\n\n\n\n\n\nTechnology Stack\n\n\nChoosing the project technology stack is one of the most important and\nlasting decisions of a project. It's almost cruel that such an\nimportant decision has to be made so early in a project life when so\nmany unknowns remain. When selecting the project technology stack,\nmany factors have to be balanced:\n\n\n\n\nStable tools with strong ecosystems and communities.\n\n\nTools which helps us develop fast, and iterate quickly.\n\n\nTools that will make us happy.\n\n\n\n\nMany times is easy to select the hip technology for a project that\nactually requires something radically different, and boring. Selecting\nthe technology stack is a lasting decision that should be \nagreed\nupon\n by the team members.\n\n\nThe following subsections list some of the common choices we have made\nat talPor, and some of the things to look out for.\n\n\nWeb apps\n\n\nWe are primarily a \nPython\n shop. We\ngenerally use \nDjango\n for our\nprojects, although we have successfully used\n\nFlask\n for smaller projects.  Additionally,\nwe have dipped our toes in the \nNode.js\n and\n\nRails\n world with varying levels of success.\n\n\nWe prefer Python and Django on the backend because there are no\nsurprises. There is no magic, there are no strongly held opinions but\nrather a set of conventions to follow.\n\n\nOn the frontend, we use plain Javascript. We generally work on top of\na framework. We have used \nAngular\n,\n\nBackbone\n, and\n\nReact\n in the past. Styling is\ngenerally done using a combination of \nSASS\n\nand \nCompass\n.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nUse starting skeletons for your projects. For Django we have found a\n  lot of success using\n  \nCookiecutter Django\n\n  and for Javascript we have enjoyed using\n  \nYeoman Generators\n.\n\n\n\n\n\n\nBe pragmatic.\n Choose the right tool for the job.\n\n\n\n\n\n\nMobile apps\n\n\nMake the pragmatic choice. While the experience is always better on\nnative applications over hybrid applications, sometimes the choice has\nto be made in the interest of development time and resources.\n\n\nAt talPor we have taken on projects that were built on top of\n\nCordova\n using\n\nIonic Framework\n with great results.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nSelect with your current project in mind. If your project needs\n  access to the latest iOS or Android features which have not landed\n  yet on PhoneGap, maybe going native is the best choice.\n\n\n\n\n\n\nFrom a designer point-of-view, designing for Android and iOS are\n  completely different stories. From screen size to the expected user\n  experience, it's all different. Keep this in mind when you decide to\n  go hybrid route.\n\n\n\n\n\n\nDatabases\n\n\nWe are strongly biased towards using\n\nPostgres\n for every new project. There\nare some up and coming NoSQL stores, like Mongo, but we deem them a\nlittle too immature for production.\n\n\nHowever, we love and use \nRedis\n as a K-V store,\ngenerally for caching and the backend for job queues.\n\n\nTooling\n\n\nChoose tools that help you during all the project stages. Your tools\nshould help you while you are developing by providing a good\ndevelopment environment. Your tools should help you make the\ntransition from local to staging and production as painlessly as\npossible.\n\n\nWe primarily use \nFabric\n, on top of the\ncommon system tools we already have available. We also enjoy using\n\nDocker\n to aid environment\nreproducibility. Other great tools are \nGrunt\n\nand \nGulp\n.\n\n\nServices\n\n\nThere are several services that solve many common problems. Don't be\nafraid to use them if they save considerable amount of development\ntime. For example, \nMandrill\n solves the\nproblem of transactional email beautifully with almost no overhead in\nintegration with the existing codebase.\n\n\nAlways keep in mind:\n\n\n\n\nConsider using services that fix non mission critical parts of your\n  project. Evaluate them, and use them if they shorten your\n  development time.\n\n\n\n\nStyle\n\n\nWhatever your technology stack, write code as idiomatically as you\ncan. Dive into your technology stack code style, follow their style,\nand avoid making one sided decisions. As a common rule of thumb, when\nyou want to do something non-idiomatic, you should be able to first\nconvince a teddy bear and then convince a team member.\n\n\nIf you need to define code style for your project (i.e. we inherited a\ncode base), document it and follow it religiously.\n\n\nOver anything, \nemphasize clean code and readability\n. Use comments\nto explain non obvious code paths. \nDon't be clever\n. Don't over\noptimize for the 1% case, think of the 99% case. If the 1% case\nbecomes a reality, you will be thankful you didn't implement the\noverly complicated, obfuscated option but the easy to follow and to\nthe point option.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nMany languages have a style guide. For example, Python has\n  \nPEP-8\n.\n\n\n\n\n\n\nMany frameworks also have a style guide. For example, Django has its\n  \nCoding Style guidelines\n.\n\n\n\n\n\n\nThere are many community-driven and company-driven efforts to define\n  good style. We enjoy following AirBnB's\n  \nJavaScript Coding Style\n. Google\n  also maintains a repository of style guides for their C++, Python,\n  Angular projects, among others.\n\n\n\n\n\n\nWhen no obvious choice can be made regarding style, select a style\n  guide by consensus, and follow it religiously.\n\n\n\n\n\n\nUse linters. Set them up to follow the agreed upon code style in\n  your project. Add configuration files to your Git repositories if\n  necessary.\n\n\n\n\n\n\nCode Reviews\n\n\nCode reviews are what happens when another person looks at code you\nwant to commit or have already commited. The main reason to have code\nreviews is to aid \ncode maintainability and catch problems\nearly\n. In small teams, it ensures that at least two pair of eyes are\nfamiliar with every bit of the codebase.\n\n\nAt talPor, we are currently following a post-commit methodology for\ncode reviews. For active projects, we perform \nmandatory\n code\naudits of every commit. It is expected for each member of the team to\nbe familiar with the code that is being committed by other team\nmembers, and to participate on regular reviews of the codebase when\ndeemed necessary. To promote code quality, an external reviewer, not\nactively working on the project, is assigned to regularly review new\ncommits of the project. The assigned external reviewer allots time\nweekly for sessions of code reviewing. Generally, two hours a week is\nmore than enough to stay on top of the latest changes in the codebase.\n\n\nWe use \nPhabricator\n for code reviews. In\nPhabricator, post-reviewing a codebase is called auditing. When new\ncommits are pushed to a project repository, Phabricator automatically\nassigns its external auditors and begins a code reviewing stage.\n\n\nBoth the author of the commit and auditors can:\n\n\n\n\nPost general comments on commits, or inline code comments, to\n  discuss the potential problems that the commit might or might not\n  have.\n\n\n\n\nAdditionally, auditors must take a decision regarding the commit:\n\n\n\n\n\n\nIf the auditor has no issues or concerns with the commit, the commit\n  can be accepted and no further discussion needs to happen.\n\n\n\n\n\n\nThe auditor can raise a concern with the commit, in which case the\n  author is notified. Ideally, after a concern is raised with a\n  commit, the author of the commit should make the changes needed to\n  get the commit to an acceptable state.\n\n\n\n\n\n\nThe Checklist\n\n\n\n\n\n\n\n\n#\n\n\nCategory\n\n\nItem\n\n\nTips\n\n\n\n\n\n\n\n\n\n\n1\n\n\nDocumentation\n\n\nAll classes, methods and functions are properly documented with clear langauge and using consistent format\n\n\nSee Item #3\n\n\n\n\n\n\n2\n\n\nDocumentation\n\n\nComplex algorithms are explained and justified\n\n\n\n\n\n\n\n\n3\n\n\nDocumentation\n\n\nNo needless, obsolete or redundant comments\n\n\n\n\n\n\n\n\n4\n\n\nDocumentation\n\n\nEdge cases and code that depends on non-obvious behavior in external libraries are well documented\n\n\n\n\n\n\n\n\n5\n\n\nDocumentation\n\n\nIncomplete code is indicated with appropiate and consistent distinctive markers (e.g. \"TODO\" or \"FIXME\") and explains how it should be completed\n\n\n\n\n\n\n\n\n6\n\n\nCoding Standards\n\n\nThe code is: understandable, adheres to code guidelines, indentation, consistent naming, unit bounds, horizontal and vertical spacing\n\n\nUse pep8 and jshint standards. See Style section on this handbook.\n\n\n\n\n\n\n7\n\n\nCoding Standards\n\n\nInline styles and scripts are avoided, if possible\n\n\n\n\n\n\n\n\n8\n\n\nCode Design\n\n\nExplicit is better than implicit. Simple is better than complex.\n\n\nimport this\n\n\n\n\n\n\n9\n\n\nCode Design\n\n\nDRY, loose coupling and tight cohesion, less code\n\n\nRead more\n\n\n\n\n\n\n10\n\n\nCode Design\n\n\nRelevant domain logic is included in the models, but models are not abused\n\n\nRead more\n --- See next point\n\n\n\n\n\n\n11\n\n\nCode Design\n\n\nLogic and presentation are not mixed\n\n\n\n\n\n\n\n\n12\n\n\nError Handling\n\n\nAll exceptions are properly caught and handled. Error messages are understandable and complete. Ensure no exceptions make it to the final user.\n\n\nThrown exceptions for invalid operations/calculations at model level should be caught at view level.\n\n\n\n\n\n\n13\n\n\nError Handling\n\n\nInvalid parameters values are handled properly early in the method and functions execution\n\n\n\n\n\n\n\n\n14\n\n\nError Handling\n\n\nLogical conditions are checked: array indexes within bounds, correct conditional guards, loops always terminate, division by zero, etc.\n\n\n\n\n\n\n\n\n15\n\n\nPerformance\n\n\nNo large synchronous tasks that affect users are done if they can be performed asynchronously\n\n\n\n\n\n\n\n\n16\n\n\nPerformance\n\n\nSQL should efficient: as few statements are executed as possible\n\n\n\n\n\n\n\n\n17\n\n\nPerformance\n\n\nStatics are served minified and uglified in production environments\n\n\n\n\n\n\n\n\n\n\nAlways keep in mind:\n\n\n\n\n\n\nCode reviews are a learning activity for all parties\n  involved. Remember the guiding principles in this process, and try\n  to learn as much as possible when giving and receiving reviews.\n\n\n\n\n\n\nIt's easier (and faster) to request a code review on small changes\n  (less than 100 lines) than on a huge feature (over 1000\n  lines). \nPush early, and push often\n. If you anticipate a big\n  feature which you want to have code reviewed, start requesting code\n  reviews as soon as possible and work on them incrementally. This\n  same advice applies to feature branches.\n\n\n\n\n\n\nPre-review your code.\n Everybody's time is valuable. Don't\n  request code reviews on code that doesn't follow code conventions,\n  lacks testing, or is sloppy. As a rule of thumb, ask yourself if you\n  would accept your code if you were the reviewer.\n\n\n\n\n\n\nIf you are reviewing code, handle requests promptly. If you don't\n  understand something stop early and ask for clarifications (either a\n  rewrite of that chunk, or better comment structure). \nDon't reject\n  code because you would have done it differently\n. The main purpose\n  of code reviews is to have \nmaintainable code\n.\n\n\n\n\n\n\nAs a reviewer, remember to check back on concerns when they are\n  fixed. As a reviewee, remember that concerns should be triaged and\n  handled on a timely fashion.\n\n\n\n\n\n\nIf a reviewer and a reviewee can't agree over a point, bring a third\n  party (another reviewer) to mediate.\n\n\n\n\n\n\nTesting\n\n\nWe strive for 100% testing coverage. Write tests religiously for your\ncode. Test both your backend and frontend, your logic, and common code\npaths. Test for invalid inputs, and malicious inputs. \nTry to break\nyour code\n. It is a lot better if you break it locally, rather than\non production.\n\n\nWhile we are not strongly opinionated on the approach you take (TDD?\nBDD? Red-Green-Refactor?), your codebase should be tested\nagainst. Prefer throughly tested libraries, frameworks and apps over\npoorly tested ones.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nGood testing means shipping working code. \nBe religious about\n  testing your codebase.\n\n\n\n\n\n\nNo testing or poor, sloppy testing will result in bad code\nreviews. Respect your teammates time, write good tests.\n\n\n\n\n\n\nTesting is central to our continuous integration system. Lacking\n  tests means that we won't be able to catch regressions or problems\n  automatically.\n\n\n\n\n\n\nProvisioning and Reproducibility\n\n\nSpend time figuring out how to make the different environments in your\nproject easily reproducible. Getting someone on-board on the project\nshould be relatively fast and easy. Adding a new server should also be\nrelatively painless. Keep clear documentation on how to install a\ndevelopment environment and how to perform a staging and production\ndeploy.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nUse your technology stack dependency managers. For example, if you\n  are using python use \npip\n.\n\n\n\n\n\n\nThere are several up and coming projects that handle reproducible\n  environments. At talPor, we have successfully used\n  \nVagrant\n and\n  \nDocker\n in the past.\n\n\n\n\n\n\nTry to make your local environment as close to staging as possible\n  and staging as close to production as possible.\n\n\n\n\n\n\nBe pragmatic about the previous point. You don't need a load\n  balancer to run your local setup.\n\n\n\n\n\n\nRead on the deployment phase for more advice.\n\n\n\n\n\n\nStaging\n\n\nStaging (also known as development) is the environment where the\nclient can test the latest changes. Ideally, it is as similar to\nproduction as possible. Setting up a staging server should be a\nimmediate priority as soon as the development phase starts.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nKeeping staging up-to-date aids communication with your\n  client\n. Bugs and issues can be found faster, and dealt with on a\n  timely fashion.\n\n\n\n\n\n\nStaging should always pass all tests!\n Everything on staging is a\n  \ncandidate\n release of your project. Treat this environment seriously:\n  as \nfew\n  bugs as possible should make it here.\n\n\n\n\n\n\nTo help automatically keep track of the previous point, we have\n  continuous integration/deployment tools set up in place. Read up on\n  the deployment phase for more advice.\n\n\n\n\n\n\nHotfixes\n\n\nThere are several ways to hotfix problems that can happen in\n\nproduction\n. If the problem is already fixed on \nmaster\n, the easiest\nway is to backport the changes. This can be done cherry-picking the\ncommits that fixes the problem (you are making atomic commits, right?)\n\n\nHowever, sometimes problems only happen or affect \nproduction\n, in\nthis case, you will need to track down the problem and prepare a\nhotfix branch. When you are done fixing the problem, make sure you\nmerge against production.\n\n\nAlways keep in mind:\n\n\n\n\nWhen hotfixing a problem, your tests should pass afterwards.\n\n\nIf new tests are needed, add them to your hotfix branch.\n\n\nUse \ngit cherry-pick -n\n to review the changes you are\n  cherry-picking before commiting them into your current branch.\n\n\n\n\nSecurity\n\n\nWhatever your project or application is, take a minute to understand\nthat what you are building will eventually have to deal with malicious\ninput and carefully crafted exploits. \nExpect the best, but prepare\nfor the worse.\n Test for malicious inputs, understand common attack\nvectors (XSS, CSRF, SQL Injections, man in the middle, ...) and\nmitigate them. Make sure you are \nalways\n testing users for the right\npermissions when trying to do something.\n\n\nUnderstand that data in production is extremely valuable, for you,\nyour client and your client's clients. \nMake scheduled backups and\nstore them off-site.\n\n\nUse SSL when dealing with sensitive information.\n Avoid storing\ncredit cards, or other sensitive information, and if you do, read on\nhow to do it \nsecurely\n. If you are processing payments, consider\nusing established carriers, like \nStripe\n.\n\n\nStay on top of CVEs and security releases related to your stack. This\nincludes system wide exploits related to your OS and libraries, and\nmaking sure your framework is running on the latest security release.\n\n\nAlways keep in mind:\n\n\n\n\n\n\nSecurity is a process, not a result.\n Plan ahead, dip your toes\n  on the attack vectors, learn to mitigate them.\n\n\n\n\n\n\nFrameworks like Django offer many built-in security provisions. Use\n  them when possible.\n\n\n\n\n\n\nFollow sites which track security releases. Our internal\n  communication system is generally updated when a new vulnerability\n  or security release of common software in our stack is released.\n\n\n\n\n\n\nDon't roll out your own authenticating system.\n But if you manage\n  to convince anyone that this is a good idea, please use strong,\n  salted, one way ciphers to store user passwords.", 
            "title": "Tech Standards"
        }, 
        {
            "location": "/development/tech/#tech-standards", 
            "text": "Source Control  From the get go, use version control. This is not negotiable. At\ntalPor we use  Git  exclusively. For open source code,\nwe publish at  GitHub  and for everything else we use\ninternal Git repositories.  Always keep in mind:    Don't rewrite public story!  Bad stuff happens when you do that,\n    kittens die. Just don't do it.    Try to make your commits as atomic as possible. If you feel like you\n  have many commits that don't quite work up to a feature (which you\n  have not yet pushed), you can squash them with a rebase.    Follow\n   Git Flow . However,\n  we keep master as develop, and production as master. Use feature and\n  hotfix branches. There are also a set of Git extensions made by nvie that\n  can be used to work with this pattern easily, get it  here .    Write good commit messages. Use a good headline and, if needed,\n  follow it by further details about the commit.    Cherish the existence of  cherry-pick  and  bisect . Learn how and when\n  to use  rebase  and  reset .    Technology Stack  Choosing the project technology stack is one of the most important and\nlasting decisions of a project. It's almost cruel that such an\nimportant decision has to be made so early in a project life when so\nmany unknowns remain. When selecting the project technology stack,\nmany factors have to be balanced:   Stable tools with strong ecosystems and communities.  Tools which helps us develop fast, and iterate quickly.  Tools that will make us happy.   Many times is easy to select the hip technology for a project that\nactually requires something radically different, and boring. Selecting\nthe technology stack is a lasting decision that should be  agreed\nupon  by the team members.  The following subsections list some of the common choices we have made\nat talPor, and some of the things to look out for.  Web apps  We are primarily a  Python  shop. We\ngenerally use  Django  for our\nprojects, although we have successfully used Flask  for smaller projects.  Additionally,\nwe have dipped our toes in the  Node.js  and Rails  world with varying levels of success.  We prefer Python and Django on the backend because there are no\nsurprises. There is no magic, there are no strongly held opinions but\nrather a set of conventions to follow.  On the frontend, we use plain Javascript. We generally work on top of\na framework. We have used  Angular , Backbone , and React  in the past. Styling is\ngenerally done using a combination of  SASS \nand  Compass .  Always keep in mind:    Use starting skeletons for your projects. For Django we have found a\n  lot of success using\n   Cookiecutter Django \n  and for Javascript we have enjoyed using\n   Yeoman Generators .    Be pragmatic.  Choose the right tool for the job.    Mobile apps  Make the pragmatic choice. While the experience is always better on\nnative applications over hybrid applications, sometimes the choice has\nto be made in the interest of development time and resources.  At talPor we have taken on projects that were built on top of Cordova  using Ionic Framework  with great results.  Always keep in mind:    Select with your current project in mind. If your project needs\n  access to the latest iOS or Android features which have not landed\n  yet on PhoneGap, maybe going native is the best choice.    From a designer point-of-view, designing for Android and iOS are\n  completely different stories. From screen size to the expected user\n  experience, it's all different. Keep this in mind when you decide to\n  go hybrid route.    Databases  We are strongly biased towards using Postgres  for every new project. There\nare some up and coming NoSQL stores, like Mongo, but we deem them a\nlittle too immature for production.  However, we love and use  Redis  as a K-V store,\ngenerally for caching and the backend for job queues.  Tooling  Choose tools that help you during all the project stages. Your tools\nshould help you while you are developing by providing a good\ndevelopment environment. Your tools should help you make the\ntransition from local to staging and production as painlessly as\npossible.  We primarily use  Fabric , on top of the\ncommon system tools we already have available. We also enjoy using Docker  to aid environment\nreproducibility. Other great tools are  Grunt \nand  Gulp .  Services  There are several services that solve many common problems. Don't be\nafraid to use them if they save considerable amount of development\ntime. For example,  Mandrill  solves the\nproblem of transactional email beautifully with almost no overhead in\nintegration with the existing codebase.  Always keep in mind:   Consider using services that fix non mission critical parts of your\n  project. Evaluate them, and use them if they shorten your\n  development time.   Style  Whatever your technology stack, write code as idiomatically as you\ncan. Dive into your technology stack code style, follow their style,\nand avoid making one sided decisions. As a common rule of thumb, when\nyou want to do something non-idiomatic, you should be able to first\nconvince a teddy bear and then convince a team member.  If you need to define code style for your project (i.e. we inherited a\ncode base), document it and follow it religiously.  Over anything,  emphasize clean code and readability . Use comments\nto explain non obvious code paths.  Don't be clever . Don't over\noptimize for the 1% case, think of the 99% case. If the 1% case\nbecomes a reality, you will be thankful you didn't implement the\noverly complicated, obfuscated option but the easy to follow and to\nthe point option.  Always keep in mind:    Many languages have a style guide. For example, Python has\n   PEP-8 .    Many frameworks also have a style guide. For example, Django has its\n   Coding Style guidelines .    There are many community-driven and company-driven efforts to define\n  good style. We enjoy following AirBnB's\n   JavaScript Coding Style . Google\n  also maintains a repository of style guides for their C++, Python,\n  Angular projects, among others.    When no obvious choice can be made regarding style, select a style\n  guide by consensus, and follow it religiously.    Use linters. Set them up to follow the agreed upon code style in\n  your project. Add configuration files to your Git repositories if\n  necessary.    Code Reviews  Code reviews are what happens when another person looks at code you\nwant to commit or have already commited. The main reason to have code\nreviews is to aid  code maintainability and catch problems\nearly . In small teams, it ensures that at least two pair of eyes are\nfamiliar with every bit of the codebase.  At talPor, we are currently following a post-commit methodology for\ncode reviews. For active projects, we perform  mandatory  code\naudits of every commit. It is expected for each member of the team to\nbe familiar with the code that is being committed by other team\nmembers, and to participate on regular reviews of the codebase when\ndeemed necessary. To promote code quality, an external reviewer, not\nactively working on the project, is assigned to regularly review new\ncommits of the project. The assigned external reviewer allots time\nweekly for sessions of code reviewing. Generally, two hours a week is\nmore than enough to stay on top of the latest changes in the codebase.  We use  Phabricator  for code reviews. In\nPhabricator, post-reviewing a codebase is called auditing. When new\ncommits are pushed to a project repository, Phabricator automatically\nassigns its external auditors and begins a code reviewing stage.  Both the author of the commit and auditors can:   Post general comments on commits, or inline code comments, to\n  discuss the potential problems that the commit might or might not\n  have.   Additionally, auditors must take a decision regarding the commit:    If the auditor has no issues or concerns with the commit, the commit\n  can be accepted and no further discussion needs to happen.    The auditor can raise a concern with the commit, in which case the\n  author is notified. Ideally, after a concern is raised with a\n  commit, the author of the commit should make the changes needed to\n  get the commit to an acceptable state.    The Checklist     #  Category  Item  Tips      1  Documentation  All classes, methods and functions are properly documented with clear langauge and using consistent format  See Item #3    2  Documentation  Complex algorithms are explained and justified     3  Documentation  No needless, obsolete or redundant comments     4  Documentation  Edge cases and code that depends on non-obvious behavior in external libraries are well documented     5  Documentation  Incomplete code is indicated with appropiate and consistent distinctive markers (e.g. \"TODO\" or \"FIXME\") and explains how it should be completed     6  Coding Standards  The code is: understandable, adheres to code guidelines, indentation, consistent naming, unit bounds, horizontal and vertical spacing  Use pep8 and jshint standards. See Style section on this handbook.    7  Coding Standards  Inline styles and scripts are avoided, if possible     8  Code Design  Explicit is better than implicit. Simple is better than complex.  import this    9  Code Design  DRY, loose coupling and tight cohesion, less code  Read more    10  Code Design  Relevant domain logic is included in the models, but models are not abused  Read more  --- See next point    11  Code Design  Logic and presentation are not mixed     12  Error Handling  All exceptions are properly caught and handled. Error messages are understandable and complete. Ensure no exceptions make it to the final user.  Thrown exceptions for invalid operations/calculations at model level should be caught at view level.    13  Error Handling  Invalid parameters values are handled properly early in the method and functions execution     14  Error Handling  Logical conditions are checked: array indexes within bounds, correct conditional guards, loops always terminate, division by zero, etc.     15  Performance  No large synchronous tasks that affect users are done if they can be performed asynchronously     16  Performance  SQL should efficient: as few statements are executed as possible     17  Performance  Statics are served minified and uglified in production environments      Always keep in mind:    Code reviews are a learning activity for all parties\n  involved. Remember the guiding principles in this process, and try\n  to learn as much as possible when giving and receiving reviews.    It's easier (and faster) to request a code review on small changes\n  (less than 100 lines) than on a huge feature (over 1000\n  lines).  Push early, and push often . If you anticipate a big\n  feature which you want to have code reviewed, start requesting code\n  reviews as soon as possible and work on them incrementally. This\n  same advice applies to feature branches.    Pre-review your code.  Everybody's time is valuable. Don't\n  request code reviews on code that doesn't follow code conventions,\n  lacks testing, or is sloppy. As a rule of thumb, ask yourself if you\n  would accept your code if you were the reviewer.    If you are reviewing code, handle requests promptly. If you don't\n  understand something stop early and ask for clarifications (either a\n  rewrite of that chunk, or better comment structure).  Don't reject\n  code because you would have done it differently . The main purpose\n  of code reviews is to have  maintainable code .    As a reviewer, remember to check back on concerns when they are\n  fixed. As a reviewee, remember that concerns should be triaged and\n  handled on a timely fashion.    If a reviewer and a reviewee can't agree over a point, bring a third\n  party (another reviewer) to mediate.    Testing  We strive for 100% testing coverage. Write tests religiously for your\ncode. Test both your backend and frontend, your logic, and common code\npaths. Test for invalid inputs, and malicious inputs.  Try to break\nyour code . It is a lot better if you break it locally, rather than\non production.  While we are not strongly opinionated on the approach you take (TDD?\nBDD? Red-Green-Refactor?), your codebase should be tested\nagainst. Prefer throughly tested libraries, frameworks and apps over\npoorly tested ones.  Always keep in mind:    Good testing means shipping working code.  Be religious about\n  testing your codebase.    No testing or poor, sloppy testing will result in bad code\nreviews. Respect your teammates time, write good tests.    Testing is central to our continuous integration system. Lacking\n  tests means that we won't be able to catch regressions or problems\n  automatically.    Provisioning and Reproducibility  Spend time figuring out how to make the different environments in your\nproject easily reproducible. Getting someone on-board on the project\nshould be relatively fast and easy. Adding a new server should also be\nrelatively painless. Keep clear documentation on how to install a\ndevelopment environment and how to perform a staging and production\ndeploy.  Always keep in mind:    Use your technology stack dependency managers. For example, if you\n  are using python use  pip .    There are several up and coming projects that handle reproducible\n  environments. At talPor, we have successfully used\n   Vagrant  and\n   Docker  in the past.    Try to make your local environment as close to staging as possible\n  and staging as close to production as possible.    Be pragmatic about the previous point. You don't need a load\n  balancer to run your local setup.    Read on the deployment phase for more advice.    Staging  Staging (also known as development) is the environment where the\nclient can test the latest changes. Ideally, it is as similar to\nproduction as possible. Setting up a staging server should be a\nimmediate priority as soon as the development phase starts.  Always keep in mind:    Keeping staging up-to-date aids communication with your\n  client . Bugs and issues can be found faster, and dealt with on a\n  timely fashion.    Staging should always pass all tests!  Everything on staging is a\n   candidate  release of your project. Treat this environment seriously:\n  as  few   bugs as possible should make it here.    To help automatically keep track of the previous point, we have\n  continuous integration/deployment tools set up in place. Read up on\n  the deployment phase for more advice.    Hotfixes  There are several ways to hotfix problems that can happen in production . If the problem is already fixed on  master , the easiest\nway is to backport the changes. This can be done cherry-picking the\ncommits that fixes the problem (you are making atomic commits, right?)  However, sometimes problems only happen or affect  production , in\nthis case, you will need to track down the problem and prepare a\nhotfix branch. When you are done fixing the problem, make sure you\nmerge against production.  Always keep in mind:   When hotfixing a problem, your tests should pass afterwards.  If new tests are needed, add them to your hotfix branch.  Use  git cherry-pick -n  to review the changes you are\n  cherry-picking before commiting them into your current branch.   Security  Whatever your project or application is, take a minute to understand\nthat what you are building will eventually have to deal with malicious\ninput and carefully crafted exploits.  Expect the best, but prepare\nfor the worse.  Test for malicious inputs, understand common attack\nvectors (XSS, CSRF, SQL Injections, man in the middle, ...) and\nmitigate them. Make sure you are  always  testing users for the right\npermissions when trying to do something.  Understand that data in production is extremely valuable, for you,\nyour client and your client's clients.  Make scheduled backups and\nstore them off-site.  Use SSL when dealing with sensitive information.  Avoid storing\ncredit cards, or other sensitive information, and if you do, read on\nhow to do it  securely . If you are processing payments, consider\nusing established carriers, like  Stripe .  Stay on top of CVEs and security releases related to your stack. This\nincludes system wide exploits related to your OS and libraries, and\nmaking sure your framework is running on the latest security release.  Always keep in mind:    Security is a process, not a result.  Plan ahead, dip your toes\n  on the attack vectors, learn to mitigate them.    Frameworks like Django offer many built-in security provisions. Use\n  them when possible.    Follow sites which track security releases. Our internal\n  communication system is generally updated when a new vulnerability\n  or security release of common software in our stack is released.    Don't roll out your own authenticating system.  But if you manage\n  to convince anyone that this is a good idea, please use strong,\n  salted, one way ciphers to store user passwords.", 
            "title": "Tech Standards"
        }, 
        {
            "location": "/deployment/", 
            "text": "The Deployment Phase\n\n\nA deploy is when you push your local changes to either the\nstaging/development server or the production server. It doesn't just\nhappen just the once when everything is done, but it's an event that\nhappens regularly, specially when you are pushing changes from local\nto staging. When you push to production you should take extra care\nbecause you might be dealing with real data from your client.\n\n\nAs a rule of thumb, we generally use AWS for all our servers since it\nprovides the highest level of flexibility and scalability you might\npossibly need.\n\n\nThe Checklist\n\n\nThis checklist is a list of stuff to make sure you are doing (or not\nand why) when setting up or deploying to a server.\n\n\n\n\n\n\nMake sure you disable password logins through SSH. \nEnable public\n  key authentication only\n. Don't change SSH server port from 22 to\n  anything else: \nSecurity by obfuscation is not security.\n\n\n\n\n\n\nUse \nsudo\n and use a good password for both your public key and\n  your account.\n\n\n\n\n\n\nSetup your firewall. Generally you'll want to block everything\n  except ports 22 (SSH), 80 (HTTP) and 443 (HTTPS).\n\n\n\n\n\n\nSetup NGINX as a reverse proxy to your application server.\n\n\n\n\n\n\nProduction should always use a trusted HTTPS certificate. Make sure\n  to get it and set it up.\n\n\n\n\n\n\nRedis is a sweet piece of software. It's so good and versatile that\n  you can use it from a cache backend to a job queue backend. Figure\n  out if you need it in your stack and set it up.\n\n\n\n\n\n\nMake sure we do not leak secrets. \nMake sure that if an API key is\n  accessible by untrusted agents then it is a public key\n. Don't\n  version control secrets. \nUse environment variables to store secret\n  keys.\n\n\n\n\n\n\nSetup automatic backups for production.\n Backup both the\n  database, and user generated content and store it \noffsite.\n\n\n\n\n\n\nLog everything. Read on Logging \n Errors below.\n\n\n\n\n\n\nAutomate your usual deploy process. We suggest using Fabric for\n  this.\n\n\n\n\n\n\nProvisioning\n\n\nWe have a set of Salt states to help with provisioning servers with\nsecure defaults. Don't be afraid to ask for them. There's an ongoing\ninternal effort to move application servers into isolated containers\n(e.g. using Docker). If that sounds interesting, don't be afraid to\nask about that either. Many of our tools, for example our CI pipeline,\nis built around the assumption that you are using Docker, so it might\nbe a good idea to use Docker from the get go.\n\n\nErrors and Logging\n\n\nAs a general rule of thumb, log everything. Log errors and\nnotices. Use your stack standard way to do this, \ndon't just spill\nprint statements all over the place.\n If you are doing something\ncritical, like handling payments, make sure you log the transaction\nonce on a log file and once on your database.\n\n\nWe internally use Sentry for error logging and notification. Setup a\ndifferent DSN for each of your servers and respond to errors swiftly.", 
            "title": "The Deployment Phase"
        }, 
        {
            "location": "/deployment/#the-deployment-phase", 
            "text": "A deploy is when you push your local changes to either the\nstaging/development server or the production server. It doesn't just\nhappen just the once when everything is done, but it's an event that\nhappens regularly, specially when you are pushing changes from local\nto staging. When you push to production you should take extra care\nbecause you might be dealing with real data from your client.  As a rule of thumb, we generally use AWS for all our servers since it\nprovides the highest level of flexibility and scalability you might\npossibly need.  The Checklist  This checklist is a list of stuff to make sure you are doing (or not\nand why) when setting up or deploying to a server.    Make sure you disable password logins through SSH.  Enable public\n  key authentication only . Don't change SSH server port from 22 to\n  anything else:  Security by obfuscation is not security.    Use  sudo  and use a good password for both your public key and\n  your account.    Setup your firewall. Generally you'll want to block everything\n  except ports 22 (SSH), 80 (HTTP) and 443 (HTTPS).    Setup NGINX as a reverse proxy to your application server.    Production should always use a trusted HTTPS certificate. Make sure\n  to get it and set it up.    Redis is a sweet piece of software. It's so good and versatile that\n  you can use it from a cache backend to a job queue backend. Figure\n  out if you need it in your stack and set it up.    Make sure we do not leak secrets.  Make sure that if an API key is\n  accessible by untrusted agents then it is a public key . Don't\n  version control secrets.  Use environment variables to store secret\n  keys.    Setup automatic backups for production.  Backup both the\n  database, and user generated content and store it  offsite.    Log everything. Read on Logging   Errors below.    Automate your usual deploy process. We suggest using Fabric for\n  this.    Provisioning  We have a set of Salt states to help with provisioning servers with\nsecure defaults. Don't be afraid to ask for them. There's an ongoing\ninternal effort to move application servers into isolated containers\n(e.g. using Docker). If that sounds interesting, don't be afraid to\nask about that either. Many of our tools, for example our CI pipeline,\nis built around the assumption that you are using Docker, so it might\nbe a good idea to use Docker from the get go.  Errors and Logging  As a general rule of thumb, log everything. Log errors and\nnotices. Use your stack standard way to do this,  don't just spill\nprint statements all over the place.  If you are doing something\ncritical, like handling payments, make sure you log the transaction\nonce on a log file and once on your database.  We internally use Sentry for error logging and notification. Setup a\ndifferent DSN for each of your servers and respond to errors swiftly.", 
            "title": "The Deployment Phase"
        }, 
        {
            "location": "/deployment/continuous-integration/", 
            "text": "Continuous Integration at talPor\n\n\nThis is an overview of how Continuous Integration (CI) is done at\ntalPor. All that is documented here is basically what we believe to be\nthe best approach for integrating your project into our internal CI\nworkflow. Read it, and make the changes you believe are needed for\nyour project.\n\n\nTechnology choices\n\n\nThis is an opinionated document. While we don't force you to use any\nof the stuff that is talked about in here, the tools we have developed\nassume many of the practices we preach about here. Particularly, our\ntechnology choices are based around the internal desire of simple\nreproducibility and commitment to ship better software that scales\ngracefully.\n\n\nThe only technology choice that cannot be avoided is \nJenkins\n as it\nis the selected CI workhorse. Besides that, all choices can be changed\nas needed. However, in this document we assume the following:\n\n\n\n\n\n\nDocker from development to production\n. Every possible\n   environment has a relevant image. Every process is dockerized into\n   a container. We recommend using our \ndocker registry\n to store\n   images and share them with your peers and between servers.\n\n\n\n\n\n\nFabric\n is used to encapsulate steps in the workflow and help\n   keep things reproducible. \nHelper tasks\n are maintained by our\n   developers.\n\n\n\n\n\n\nVersion Controlling for Good CI\n\n\nThe general idea of a CI workflow is as follows:\n\n\ngit push origin master -\n Begin CI Pipeline -\n If everything is OK\n(i.e. all tests pass) -\n Push new build\n\n\nAt talPor, we follow Git Flow. As it is recommended, we have a\nmainline which is what production is currently running, and a\ndevelopment line which is where all development happens. Our mainline\nbranch is called \nproduction\n and our development branch is called\n\ndevelopment\n (some projects call it staging). As can be expected,\nproduction servers run on top of the \nproduction\n branch, and\ndevelopment/staging servers run on top of the \ndevelopment\n branch.\n\n\nDevelopers create feature branches on top of \ndevelopment\n. When a new\nfeature is ready, it is merged into \ndevelopment\n.  When a new push is\nready to be made to production, \ndevelopment\n is merged into it and\nthen pushed. A similar process happens when there is a hotfix that\nneeds to be applied.\n\n\nWe have extended Git Flow to follow a better suited CI flow. The\ngeneral idea of CI is that every change that makes it into\n\ndevelopment\n and \nproduction\n should be as problem-free as\npossible. As such, we have decided to make the invariant of the\n\ndevelopment\n branch the following:\n\n\nAt any given moment, \ndevelopment\n is a candidate release of the\n  project.\n\n\nAs such, \ndevelopment\n should be ready to be merged into \nproduction\n\nand be as problem-free as possible. We define \nproblem-free\n as \nall\ntests pass\n. To avoid human error (merges when some test fails), when\nusing CI, \ndevelopment\n is handled by a machine (i.e. changes are\npushed by Jenkins), and \nit is not allowed to manually push changes\ninto it\n. To allow for development to happen, we have added a new\nbranch, \nmaster\n, in which development continues normally.\n\n\nStacking Environments\n\n\nIf you are using Docker containers, we strongly suggest you\nencapsulate your environments into different images for each\nenvironment. Try to move common and repeated behavior into common\nimages, and extend those images.\n\n\n\n\n\n\nCommon.\n The common steps in all your images. This is the root of\n  your build tree. Common tasks to perform here are installing system\n  dependencies and setting up global environment variables.\n\n\n\n\n\n\nLocal (extends Common).\n The environment developers will use in\n  their personal machines. Common tasks to perform here are installing\n  developer tools and requirements for local.\n\n\n\n\n\n\nTesting (extends Common).\n The environment where tests are\n  run. This environment is central to CI. Make sure running your tests\n  is the entrypoint for this environment.\n\n\n\n\n\n\nProduction (extends Common).\n The environment used by production\n  servers.\n\n\n\n\n\n\nDevelopment (extends Production).\n The environment used in\n  staging or development servers. Should be as similar to production\n  as possible.\n\n\n\n\n\n\nSince keeping all your environment up-to-date can be a hassle, we have\nan internal Docker registry where we store the latest images so they\ncan be pulled from as soon as a build is done.\n\n\nThe Generic Pipeline\n\n\nOur recommended CI pipeline for our software projects is described\nbelow. The first step is triggered when a push with changes on\n\nmaster\n is received.\n\n\n\n\n\n\nBuild new Docker images, if necessary.\n Checks into the new\n   pushed files are performed to detect whether or not to trigger a\n   build. \nOnly relevant environment should be rebuilt\n. For\n   example, if the Common needs to be rebuilt, every image needs to be\n   rebuilt, but if the Production image needs to be rebuilt, only\n   Production and Development needs rebuilding. If any image fails to\n   be built, the pipeline is stopped, and developers notified.\n\n\n\n\n\n\nRun Tests.\n Using your Testing environment, spin a new\n   container, and wait for tests to run. If all tests pass, move to\n   step 3. If any test fail, then notify developers a build has failed\n   to build.\n\n\n\n\n\n\nPush changes.\n Merge \nmaster\n into development (those changes\n   don't break anything), and push all the rebuilt images to the\n   registry.\n\n\n\n\n\n\nDeploy\n. Deploy changes to all the environment you want. By\n   default, we suggest automatically pushing into staging/development\n   and manually pushing to production when wanted.\n\n\n\n\n\n\nNotifications \n Broken Builds\n\n\nNotifications happen any time that a build fails. \nWhen a build\nfails, the whole team should focus on making \nmaster\n succesfully\nbuild again\n. Notifications are sent via email to developers and team\nmembers, and Slack spam happens. \nDon't ignore broken builds.", 
            "title": "Continuous Integration"
        }, 
        {
            "location": "/deployment/continuous-integration/#continuous-integration-at-talpor", 
            "text": "This is an overview of how Continuous Integration (CI) is done at\ntalPor. All that is documented here is basically what we believe to be\nthe best approach for integrating your project into our internal CI\nworkflow. Read it, and make the changes you believe are needed for\nyour project.  Technology choices  This is an opinionated document. While we don't force you to use any\nof the stuff that is talked about in here, the tools we have developed\nassume many of the practices we preach about here. Particularly, our\ntechnology choices are based around the internal desire of simple\nreproducibility and commitment to ship better software that scales\ngracefully.  The only technology choice that cannot be avoided is  Jenkins  as it\nis the selected CI workhorse. Besides that, all choices can be changed\nas needed. However, in this document we assume the following:    Docker from development to production . Every possible\n   environment has a relevant image. Every process is dockerized into\n   a container. We recommend using our  docker registry  to store\n   images and share them with your peers and between servers.    Fabric  is used to encapsulate steps in the workflow and help\n   keep things reproducible.  Helper tasks  are maintained by our\n   developers.    Version Controlling for Good CI  The general idea of a CI workflow is as follows:  git push origin master -  Begin CI Pipeline -  If everything is OK\n(i.e. all tests pass) -  Push new build  At talPor, we follow Git Flow. As it is recommended, we have a\nmainline which is what production is currently running, and a\ndevelopment line which is where all development happens. Our mainline\nbranch is called  production  and our development branch is called development  (some projects call it staging). As can be expected,\nproduction servers run on top of the  production  branch, and\ndevelopment/staging servers run on top of the  development  branch.  Developers create feature branches on top of  development . When a new\nfeature is ready, it is merged into  development .  When a new push is\nready to be made to production,  development  is merged into it and\nthen pushed. A similar process happens when there is a hotfix that\nneeds to be applied.  We have extended Git Flow to follow a better suited CI flow. The\ngeneral idea of CI is that every change that makes it into development  and  production  should be as problem-free as\npossible. As such, we have decided to make the invariant of the development  branch the following:  At any given moment,  development  is a candidate release of the\n  project.  As such,  development  should be ready to be merged into  production \nand be as problem-free as possible. We define  problem-free  as  all\ntests pass . To avoid human error (merges when some test fails), when\nusing CI,  development  is handled by a machine (i.e. changes are\npushed by Jenkins), and  it is not allowed to manually push changes\ninto it . To allow for development to happen, we have added a new\nbranch,  master , in which development continues normally.  Stacking Environments  If you are using Docker containers, we strongly suggest you\nencapsulate your environments into different images for each\nenvironment. Try to move common and repeated behavior into common\nimages, and extend those images.    Common.  The common steps in all your images. This is the root of\n  your build tree. Common tasks to perform here are installing system\n  dependencies and setting up global environment variables.    Local (extends Common).  The environment developers will use in\n  their personal machines. Common tasks to perform here are installing\n  developer tools and requirements for local.    Testing (extends Common).  The environment where tests are\n  run. This environment is central to CI. Make sure running your tests\n  is the entrypoint for this environment.    Production (extends Common).  The environment used by production\n  servers.    Development (extends Production).  The environment used in\n  staging or development servers. Should be as similar to production\n  as possible.    Since keeping all your environment up-to-date can be a hassle, we have\nan internal Docker registry where we store the latest images so they\ncan be pulled from as soon as a build is done.  The Generic Pipeline  Our recommended CI pipeline for our software projects is described\nbelow. The first step is triggered when a push with changes on master  is received.    Build new Docker images, if necessary.  Checks into the new\n   pushed files are performed to detect whether or not to trigger a\n   build.  Only relevant environment should be rebuilt . For\n   example, if the Common needs to be rebuilt, every image needs to be\n   rebuilt, but if the Production image needs to be rebuilt, only\n   Production and Development needs rebuilding. If any image fails to\n   be built, the pipeline is stopped, and developers notified.    Run Tests.  Using your Testing environment, spin a new\n   container, and wait for tests to run. If all tests pass, move to\n   step 3. If any test fail, then notify developers a build has failed\n   to build.    Push changes.  Merge  master  into development (those changes\n   don't break anything), and push all the rebuilt images to the\n   registry.    Deploy . Deploy changes to all the environment you want. By\n   default, we suggest automatically pushing into staging/development\n   and manually pushing to production when wanted.    Notifications   Broken Builds  Notifications happen any time that a build fails.  When a build\nfails, the whole team should focus on making  master  succesfully\nbuild again . Notifications are sent via email to developers and team\nmembers, and Slack spam happens.  Don't ignore broken builds.", 
            "title": "Continuous Integration at talPor"
        }, 
        {
            "location": "/wrapup/", 
            "text": "Goodbye\n\n\ntalPor\n strongly believes that you build the\ncompany you want to work for. As such, we are constantly iterating,\ntesting new hypothesis, and validating. This document is\nalways-changing, and we welcome thoughts, ideas, and suggestions to\nimprove our process.\n\n\nReferences\n\n\n\n\nTrello\n\n\nSlack\n\n\nGit\n\n\nGit Flow\n\n\ntalPor\n\n\nGitHub\n\n\npip\n\n\nDocker\n\n\nVagrant\n\n\nDjango\n\n\nPython\n\n\nFlask\n\n\nNode.js\n\n\nRails\n\n\nCompass\n\n\nSASS\n\n\nAngular\n\n\nBackbone\n\n\nReact\n\n\nStripe", 
            "title": "Wrap-up"
        }
    ]
}